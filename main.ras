program main;

@define USE_KERNAL 0
@define PREFAB_SIZE 1
@define SCENES_SIZE 1
@define DIMX 20
@define DIMY 12
@define DIMZ 4
@define DIMTILES 240
@define Z_BACK2 3
@define Z_BACK1 2
@define Z_MAIN 1
@define Z_FRONT 0

@define ID_TEXTBOX 128
@define ID_IMAGEBOX 129
@define ID_MENU 130
@define STATE_PLAY 0
@define STATE_DO_NOTHING 1
@define STATE_PAUSE_TAGS 2
@define STATE_PAUSE_ALL 3

@define DURATION_KILL 50

@define SCRIPT_INIT 0
@define SCRIPT_PLAY 1

@define COMP_TRANSFORM_0    %00000001
@define COMP_RENDER_0       %00000010
@define COMP_PHYSICS_0      %00000100
@define COMP_COLLIDE_ABLE_0 %00001000
 
@define LEV_BRICK $01
@define LEV_STONE $0f
@define BANK0 $04
@define BANK1 $44


@startblock $8000 "Variables"

var	
	// Charset at $2000
	@define charLoc $4800
	@define tilesetLoc1 $1000
	@define tilesetLoc2 $5000
	// Automatically export charsets 
	@export "charsets/tileset.flf" "charsets/tileset.bin" 256	
	@export "charsets/charset.flf" "charsets/charset.bin" 256	
   	tileset1: incbin("charsets/tileset.bin", @tilesetLoc1);
	// Pointer that will point to character data location at $2000+$800=$2800
   	tileset2: incbin("charsets/tileset.bin", @tilesetLoc2);
	// Pointer that will point to character data location at $2000+$800=$2800
	tilesetColors :  incbin("charsets/tileset_color.bin", @tilesetLoc2+$800);
   	charset1: incbin("charsets/charset.bin", @charLoc);
	// Pointer that will point to character data location at $2000+$800=$2800
	i,j: byte;
	currentBank: byte=@BANK0;
	hiddenBank: byte=@BANK1;
		
gobject = class
		id: byte;
		isActive : boolean;
		components: array[4] of byte;
		
		// TransformTile
		transX, transY, transZ, transPriority, transRot: byte;
	
		// Render
		rendToMove, rendDrawEnergy, rendInAnimCycle : boolean;
		rendPathStep: Array[] of byte;
		rendLastXpos, rendLastYpos, rendLastPathElem, rendMoveoffsetx, rendMoveoffsety, rendCenterX, rendCentery: byte;
		rendEnergyX, rendEnergyY, rendEnergyPercent, rendTilePos: byte;
	end;
	time:byte;
	movex: byte=1;
	lev0: cstring = ("aaaaaaaaaaaaaaaaaaaaao                 aa                  aa                  aa                  aa                  aa                  aa                  aa                  aa                  aa                  aa                  aa");
	objectList : Array[254] of gobject;
	mapback2 : Array[@DIMTILES] of byte;
	mapback1 : Array[@DIMTILES] of byte;
	mapmain : Array[@DIMTILES] of byte;
	mapfront : Array[@DIMTILES] of byte;
	deltamoves : Array[254] of byte;
	deltamoveCount: byte;
	script : byte;
	frame, newSceneId, state, oldState: byte;
	counter: integer;
	killDuration, killTimer: byte;
	// TODO: TextBox pause
	newSceneAfterKill: boolean;
@endblock

@startblock $1800 "Main"

procedure Init();
begin
	counter := 0;
	frame := 0;
	newSceneId := 255;
	state := @STATE_PLAY;
	oldState := 255;
	script := @SCRIPT_INIT;
	killDuration := 0;
	killTimer := 0;
	newSceneAfterKill := true;
end;

procedure SwitchBank();
begin
	if (currentBank = @BANK0) then 
	begin
		SetBank(VIC_BANK1);
//		src:=#screen_char_loc2;
//		dst:=#screen_char_loc+screen_width;
		setcharsetlocation(@tilesetLoc2);
		currentBank := @BANK1;
		hiddenBank := @BANK0;
	end
	else 
	begin
		SetBank(VIC_BANK0);
//		src:=#screen_char_loc;
//		dst:=#screen_char_loc2+screen_width;
		setcharsetlocation(@tilesetLoc1);
		currentBank := @BANK0;
		hiddenBank := @BANK1;
	end;

end;


procedure AddMapItem(amiId: byte, amix: byte, amiy: byte, amiz:byte);
var
	pos: byte;
begin
	pos := amix + amiy * @DIMX;
	case amiz of
		@Z_BACK2: mapback2[pos] := amiId;
		@Z_BACK1: mapback1[pos] := amiId;
		@Z_MAIN: mapmain[pos] := amiId;
		@Z_FRONT: mapfront[pos] := amiId;
	end;
end;

procedure ClearMap();
var 
	m: byte;
begin
    for m := 0 to @DIMTILES do	
	begin
 	 	mapback2[m] := 255;
 	 	mapback1[m] := 255;
 	 	mapmain[m] := 255;
 	 	mapfront[m] := 255;
 	end;
end;

procedure InitBrick(ibi: byte, ibx: byte, iby: byte);
var 
	pg: pointer of gobject;
begin
	pg := #objectList[ibi];
	pg.id := ibi;
	pg.rendTilePos := 0;
	pg.components[0] := @COMP_TRANSFORM_0|@COMP_RENDER_0|@COMP_COLLIDE_ABLE_0;
	pg.components[1] := $00;
	pg.components[2] := $00;
	pg.components[3] := $00;
	pg.isActive := true;
	pg.transX := ibx;
	pg.transY := iby;
	pg.transZ := @Z_MAIN;
	AddMapItem(ibi, ibx, iby, @Z_MAIN);
end;

procedure InitStone(i: byte, x: byte; y: byte);
var 
	pg: pointer of gobject;
begin
	pg := #objectList[i];
	pg.id := i;
	pg.rendTilePos := 4;
	pg.components[0] := @COMP_TRANSFORM_0|@COMP_RENDER_0|@COMP_PHYSICS_0|@COMP_COLLIDE_ABLE_0;
	pg.components[1] := $00;
	pg.components[2] := $00;
	pg.components[3] := $00;
	pg.isActive := true;
	pg.transX := x;
	pg.transY := y;
	pg.transZ := @Z_MAIN;
	AddMapItem(i, x, y, @Z_MAIN);
end;
	
procedure InitMap();
var 
	i,x,y,c : byte;
	newObj : gobject;
begin
	ClearMap();
	for i := 0 to @DIMTILES do
	begin
		c := lev0[i];
		x := mod(i,@DIMX);
		y := i / @DIMX;
//		moveto(x*2,y*2,hi(#screen_char_loc2));
//		printnumber(c);
		case c of
			@LEV_BRICK: InitBrick(i, x, y);
			@LEV_STONE: InitStone(i, x, y);
		end;
	end;
end;

procedure print2x2block(p22x,p22y,p22c:byte);
begin
	moveto(p22x*2,p22y*2,hiddenBank);
	screenmemory[0]:=p22c;
	screenmemory[1]:=p22c+1;
	screenmemory[40]:=p22c+40;
	screenmemory[41]:=p22c+41;

	moveto(p22x*2,p22y*2,hiddenBank);
	screenmemory[0]:=tilesetColors[p22c]+8;
	screenmemory[1]:=tilesetColors[p22c+1]+8;
	screenmemory[40]:=tilesetColors[p22c+40]+8;;
	screenmemory[41]:=tilesetColors[p22c+41]+8;;
end;


procedure print2x2blockEmpty(x,y:byte);
begin
	moveto(x*2,y*2,hiddenBank);
	screenmemory[0]:=255;
	screenmemory[1]:=255;
	screenmemory[40]:=255;
	screenmemory[41]:=255;
end;

procedure PaintPos(pos: byte);
var
	x,y: byte;
	t: byte;
	pg: pointer of gobject;
begin
	x := mod(pos,@DIMX);
	y := pos / @DIMX;
	moveto(0,0,$44);
	printnumber(x);
	moveto(4,0,$44);
	printnumber(x);

	print2x2blockEmpty(x,y);
	
	if(mapback2[pos] <> 255) then begin
 	end;
 	if(mapback1[pos] <> 255) then begin
 	end;
 	t := mapmain[pos];
 	if(t <> 255) then begin
	 	pg := #objectList[pos];
		print2x2block(x,y,pg.rendTilePos);
 	end;
 	if(mapfront[pos] <> 255) then begin
	end;
	
end;
	
procedure PaintFull();
var
	i,x,y: byte;
	t: byte;
	o: gobject;
	pg : pointer of gobject;
	g: byte;
begin
    for i := 0 to @DIMTILES do
	begin
		PaintPos(i);
	end;
end;

procedure ChangeMapItem(cmiid: byte, cmioldx: byte, cmioldy: byte, cmix: byte, cmiy: byte, cmiz:byte, tilepos: byte);
var
	oldpos: byte;
	pos,t: byte;
	pg: pointer of gobject;
begin
	oldpos := cmioldx + cmioldy * @DIMX;
	pos := cmix + cmiy * @DIMX;
	case cmiz of
		@Z_BACK2: 
			begin
				mapback2[oldpos] := 255; 
				mapback2[pos] := cmiid;
			end;
		@Z_BACK1: 
			begin
				mapback1[oldpos] := 255; 
				mapback1[pos] := cmiid;
			end;
		@Z_MAIN: 
			begin
				mapmain[oldpos] := 255; 
				mapmain[pos] := cmiid;
 	 		end;
		@Z_FRONT: 
			begin
				mapfront[oldpos] := 255; 
				mapfront[pos] := cmiid;
			end;
	end;
	PaintPos(oldpos);
	PaintPos(pos);
end;

procedure DeleteMapItem(dmiid: byte, dmix: byte, dmiy: byte, dmiz:byte);
var	
	pos: byte;
begin
	pos := dmix + dmiy * @DIMX;
	case dmiz of
		@Z_BACK2: 
			begin
				mapback2[pos] := 255; 
			end;
		@Z_BACK1: 
			begin
				mapback1[pos] := 255;
			end;
		@Z_MAIN: 
			begin
				mapmain[pos] := 255;
			end;
		@Z_FRONT: 
			begin
				mapfront[pos] := 255;
			end;
	end;
end;
	
	
procedure SetPos(spi: byte,spx: byte, spy: byte, spz: byte);
var
	oldx, oldy, oldz: byte;
	pg: pointer of gobject;
begin
	pg := #objectList[spi];
	oldx := pg.transX;
	oldy := pg.transY;
	oldz := pg.transZ;
	pg.transX := spx;
	pg.transY := spy;
	pg.transZ := spz;
	ChangeMapItem(spi, oldx, oldy, spx, spy, spz, pg.rendTilePos);
end;
	
procedure DeletePos(dpi: byte);
begin
	objectList[dpi].isActive := false;
	DeleteMapItem(objectList[dpi].transX, objectList[dpi].transY, objectList[dpi].transZ);
end;


interrupt RasterBottomText();

interrupt RasterTopLevel();
var
	i: byte;
begin
	startirq(@USE_KERNAL);
	poke(^$d418,0,31);
	//setcharsetlocation(@tilesetLoc2);
	SwitchBank();
	SetPos(2,2,movex,@Z_MAIN);
	SetPos(3,3,movex,@Z_MAIN);
	SetPos(4,4,movex,@Z_MAIN);
	SetPos(5,5,movex,@Z_MAIN);
	SetPos(6,6,movex,@Z_MAIN);
	SetPos(7,7,movex,@Z_MAIN);
	SetPos(8,8,movex,@Z_MAIN);
	SetPos(9,9,movex,@Z_MAIN);
	inc(movex);
	if(movex = 11) then movex :=0;
	
	setmulticolormode();
	RasterIRQ(RasterBottomText(), 242, @USE_KERNAL);
	closeIrq();
end;

interrupt RasterBottomText();
var
	i: byte;
begin
	startirq(@USE_KERNAL);
	setcharsetlocation(@charLoc);
	setregularcolormode();
	RasterIRQ(RasterTopLevel(),20,@USE_KERNAL);
	time := 0;
	moveto(8,24,$44);
	printstring("HELLO",0,40);
	closeIrq();
end;
@endblock

begin
	SCREEN_BG_COL:=BLACK;
	SCREEN_FG_COL:=BLACK;
	SPRITE_BITMASK:=0;
	multicolor_char_col[1]:=brown;
	multicolor_char_col[2]:=grey;
	setmulticolormode();
	setbank(VIC_BANK1);
	clearscreen($FF,^$4400);
	//clearscreen(LIGHT_BLUE,^$D800);
	setcharsetlocation(@tilesetLoc1);
	
	Init();
	InitMap();
	SwitchBank();
	PaintFull();
	SwitchBank();
	PaintFull();
	disableciainterrupts(); // prevent CIA
	setmemoryconfig(1,0,@USE_KERNAL); // Enable all ram, turn off BASIC
	StartRasterChain(RasterTopLevel(), 0,@USE_KERNAL); // Don't use kernal
		

	Loop(); 
end.


