procedure ReleaseKeys(id: byte);
var 
	controlId : byte;
begin
	controlId := objectList[id].controlId;
	controlList[controlId].b_controlPressLeft := false;
	controlList[controlId].b_controlPressRight := false;
	controlList[controlId].b_controlPressDown := false;			
	controlList[controlId].b_controlPressUp := false;
//	controlList[controlId].b_controlPressAction := false;
end;

procedure ProcessBackObj(id: byte);
var
	controlId : byte;
	defWalk: boolean;
	gravity: byte;
	backObj, backObj2: byte;
	pos,v: byte;
	robeAbleId, portalId, gravPadId, switchId:  byte;
	newx, newy: byte;
begin
	defWalk := true;
	controlId := objectList[id].controlId;
	if(objectList[id].b_hasMoved = true) then begin
		robeAbleId := GetObjectByPosFilterComp(objectList[id].transX, objectList[id].transY, @Z_BACK1, @COMP_ROBE_ABLE_1, 1);
		portalId := GetObjectByPosFilterComp(objectList[id].transX, objectList[id].transY, @Z_BACK1, @COMP_PORTAL_1, 1);
		gravPadId := GetObjectByPosFilterComp(objectList[id].transX, objectList[id].transY, @Z_BACK1, @COMP_GRAVPAD_1, 1);
		
		if(GetObjectByPosFilterComp(objectList[id].transX, objectList[id].transY, @Z_BACK1, @COMP_CLIMB_ABLE_1, 1) <> $FF) then begin	
			objectList[id].b_physFallDown := false;
			SwitchAnimation(id, @ANIM_CLIMB);
			controlList[controlId].controlState := @CTRL_STATE_CLIMB;
			defWalk := false;
		end
		else if(robeAbleId <> $FF) then begin	
			if (objectList[robeAbleId].physGravity = objectList[id].physGravity) then begin
				objectList[id].b_physFallDown := false;
				controlList[controlId].controlState := @CTRL_STATE_ROBE;
				SwitchAnimation(id, @ANIM_ROBE);
				defWalk := false;
			end;
		end
		else if(portalId <> $FF and (controlList[controlId].controlLastPortal = $FF or controlList[controlId].controlLastPortal = portalId)) then begin
			newx := $FF;
			newy := $FF;
			if(portals[0] <> $FF and portals[1] <> $FF) then begin
				if(portals[0] = portalId) then begin
					newx := objectList[portals[1]].transX;
					newy := objectList[portals[1]].transY;
					controlList[controlId].controlLastPortal := portalId;
				end
				else if(portals[1] = portalId) then begin
					newx := objectList[portals[0]].transX;
					newy := objectList[portals[0]].transY;
					controlList[controlId].controlLastPortal := portalId;
				end;
			end;
			if(newx <> $FF) then SetPos(id, objectList[id].transX, objectList[id].transY, newx, newy, objectList[id].transZ);
			defWalk := true;
		end
		else if(GetObjectByPosFilterComp(objectList[id].transX, objectList[id].transY, @Z_BACK2, @COMP_WATER_0, 0) <> $FF) then begin	
			if(objectList[id].component1 & @COMP_FLOATER_1 = @COMP_FLOATER_1) then begin
				objectList[id].b_physFallDown := false;
				if(objectList[id].animId <> @ANIM_SWIM_L and objectList[id].animId <> @ANIM_SWIM_R) then SwitchAnimation(id, @ANIM_SWIM_L);
				controlList[controlId].controlState := @CTRL_STATE_SWIM;
				defWalk := false;
			end
		end
		else if(gravPadId <> $FF) then begin
			objectList[id].physGravity := objectList[gravPadId].physGravity;
		end;
		
		if(defWalk = true) then begin 
			if(controlList[controlId].controlState <> @CTRL_STATE_JUMP) then	begin
				if(objectList[id].animId <> @ANIM_WALK_L and objectList[id].animId <> @ANIM_WALK_R) then SwitchAnimation(id, @ANIM_STAND);
				controlList[controlId].controlState := @CTRL_STATE_WALK;
 				objectList[id].b_physFallDown := true;
 			end;
		end;
		if(portalId = $FF) then controlList[controlId].controlLastPortal := $FF;

		if(controlList[controlId].lastWaypointId = $FF and controlList[controlId].waypointId <> $FF) then begin
			DispatchEvent(@EVENT_WAYPOINT_ENTER, controlList[controlId].waypointId, $FF, $FF);
		end
		else if((controlList[controlId].lastWaypointId <> $FF and controlList[controlId].waypointId <> $FF) and controlList[controlId].lastWaypointId <> controlList[controlId].waypointId) then begin
			DispatchEvent(@EVENT_WAYPOINT_LEAVE, controlList[controlId].lastWaypointId, $FF, $FF);
			DispatchEvent(@EVENT_WAYPOINT_ENTER, controlList[controlId].waypointId, $FF, $FF);
		end
		else if(controlList[controlId].lastWaypointId <> $FF and controlList[controlId].waypointId = $FF) then begin
			DispatchEvent(@EVENT_WAYPOINT_LEAVE, controlList[controlId].lastWaypointId, $FF, $FF);	
		end;
	end;
	
 
	switchId := GetObjectByPosFilterComp(objectList[id].transX, objectList[id].transY, @Z_BACK1, @COMP_SWITCH_2, 2);
	if(switchId <> $FF) then begin
		if(controlList[controlId].b_controlPressAction = true) then begin
			textTimer := 20;
			if(objectList[switchId].onOff = @ON) then begin
				PrintText(@DEACTIVATE_SWITCH_START,#txtDeactiveSwitch);
				SwitchAnimation(switchId,@ANIM_SWITCH_OFF);
				objectList[switchId].onOff := @OFF;
				controlList[controlId].b_controlPressAction := false;
				DispatchEvent(@EVENT_SWITCH_OFF, switchId, $FF, $FF);
			end
			else begin
				PrintText(@ACTIVATE_SWITCH_START,#txtActiveSwitch);
				SwitchAnimation(switchId,@ANIM_SWITCH_ON);
				objectList[switchId].onOff := @ON;
				controlList[controlId].b_controlPressAction := false;
				DispatchEvent(@EVENT_SWITCH_ON, switchId, $FF, $FF);
			end;
		end;
	end
end;

procedure InputControl(id: byte);
var
	controlId : byte;
	gravity: byte;
begin
	controlId := objectList[id].controlId;
	ReleaseKeys(id);
	if(objectList[id].component0 & @COMP_PHYSICS_0 = @COMP_PHYSICS_0) then gravity := objectList[id].physGravity else gravity := @DOWN ;
	if(joy2 = $80 and controlList[controlId].b_controlPressAction = true) then begin 
		controlList[controlId].b_controlPressAction := false;
	end;
		
	if(joy2 = $90 and controlList[controlId].b_controlPressAction = false) then begin
		controlList[controlId].b_controlPressAction := true;
	end;
	if(joy2 & joy_fire = joy_fire) then
		// ignore		
	else begin
		if(joy2 & joy_left = joy_left) then begin
			if(gravity = @DOWN) then controlList[controlId].b_controlPressLeft := true;
			if(gravity = @UP) then controlList[controlId].b_controlPressRight := true;
			if(gravity = @LEFT) then controlList[controlId].b_controlPressDown := true;			
			if(gravity = @RIGHT) then controlList[controlId].b_controlPressUp := true;			
		end;
		if(joy2 & joy_left <> joy_left) then begin
			if(gravity = @DOWN) then controlList[controlId].b_controlPressLeft := false;
			if(gravity = @UP) then controlList[controlId].b_controlPressRight := false;
			if(gravity = @LEFT) then controlList[controlId].b_controlPressDown := false;			
			if(gravity = @RIGHT) then controlList[controlId].b_controlPressUp := false;			
		end;
		if(joy2 & joy_right) then begin
			if(gravity = @DOWN) then controlList[controlId].b_controlPressRight := true;
			if(gravity = @UP) then controlList[controlId].b_controlPressLeft := true;
			if(gravity = @LEFT) then controlList[controlId].b_controlPressUp := true;			
			if(gravity = @RIGHT) then controlList[controlId].b_controlPressDown := true;
		end;
		if(joy2 & joy_right <> joy_right) then begin
			if(gravity = @DOWN) then controlList[controlId].b_controlPressRight := false;
			if(gravity = @UP) then controlList[controlId].b_controlPressLeft := false;
			if(gravity = @LEFT) then controlList[controlId].b_controlPressUp := false;			
			if(gravity = @RIGHT) then controlList[controlId].b_controlPressDown := false;			
		end;
		if(joy2 & joy_up = joy_up) then begin
			if(gravity = @DOWN) then controlList[controlId].b_controlPressUp := true;
			if(gravity = @UP) then controlList[controlId].b_controlPressDown := true;
			if(gravity = @LEFT) then controlList[controlId].b_controlPressLeft := true;			
			if(gravity = @RIGHT) then controlList[controlId].b_controlPressRight := true;
		end;
		if(joy2 & joy_up <> joy_up) then begin
			if(gravity = @DOWN) then controlList[controlId].b_controlPressUp := false;
			if(gravity = @UP) then controlList[controlId].b_controlPressDown := false;
			if(gravity = @LEFT) then controlList[controlId].b_controlPressLeft := false;			
			if(gravity = @RIGHT) then controlList[controlId].b_controlPressRight := false;
		end;
		if(joy2 & joy_down = joy_down) then begin
			if(gravity = @DOWN) then controlList[controlId].b_controlPressDown := true;
			if(gravity = @UP) then controlList[controlId].b_controlPressUp := true;
			if(gravity = @LEFT) then controlList[controlId].b_controlPressRight := true;			
			if(gravity = @RIGHT) then controlList[controlId].b_controlPressLeft := true;
		end;
		if(joy2 & joy_down <> joy_down) then begin
			if(gravity = @DOWN) then controlList[controlId].b_controlPressDown := false;
			if(gravity = @UP) then controlList[controlId].b_controlPressUp := false;
			if(gravity = @LEFT) then controlList[controlId].b_controlPressRight := false;			
			if(gravity = @RIGHT) then controlList[controlId].b_controlPressLeft := false;
		end;
	end;
end;

procedure UpdateControl(id: byte);
var
	controlId : byte;
	grounded: boolean;
	isShift: boolean;
	gravity: byte;
	oldx, oldy, newx, newy, moveDir: byte; 

	shift: integer;
	d: byte;

	colObj, eraseObj, colObj2, eraseObj2: byte;
	shiftDir: byte;
begin
	controlId := objectList[id].controlId;
	moveDir := $FF;
	grounded := false;
	isShift := false;
	shift := 0;
	shiftDir := $FF;
	gravity := $FF;
	newx := $FF;
	newy := $FF;
	
	if(objectList[id].component0 & @COMP_PHYSICS_0 <> @COMP_PHYSICS_0) then begin
		grounded := true;
		isShift := false;
		gravity := @DOWN;
	end
	else begin
		gravity := objectList[id].physGravity;
		colObj := GetObjArea(id, objectList[id].transZ, 7, @COMP_COLLIDE_ABLE_0,0, false);
		if(colObj <> $FF) then begin 
			grounded := true;
			shiftDir := objectList[colObj].shiftDir;
			if ((gravity = @DOWN and shiftDir = @LEFT) or (gravity = @DOWN and shiftDir = @RIGHT)) then isShift:= true;
			if ((gravity = @LEFT and shiftDir = @LEFT) or (gravity = @LEFT and shiftDir = @RIGHT)) then isShift:= true; 
			if ((gravity = @UP and shiftDir = @LEFT) or  (gravity = @UP and shiftDir = @RIGHT)) then isShift:= true;
			if ((gravity = @RIGHT and shiftDir = @LEFT) or (gravity = @RIGHT and shiftDir = @RIGHT)) then isShift := true;
		end;
	end;
	if(controlList[controlId].controlState = @CTRL_STATE_WALK) then begin
		if(isShift = false) then begin
			colObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_DESTROY_COLLIDE_0,0, false);
			if((colObj <> $FF and controlList[controlId].b_controlPressLeft = true) and (controlList[controlId].b_controlPressUp = false and grounded = true)) then DamageCollide(colObj);
			
			colObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_DESTROY_COLLIDE_0,0, false);
			if((colObj <> $FF and controlList[controlId].b_controlPressRight = true) and (controlList[controlId].b_controlPressUp = false and grounded = true)) then DamageCollide(colObj);
			
			colObj := GetObjArea(id, objectList[id].transZ, 7, @COMP_DESTROY_COLLIDE_0,0, false);
			if((colObj <> $FF and controlList[controlId].b_controlPressDown = true) and grounded = true) then DamageCollide(colObj);
			
			colObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_COLLIDE_ABLE_0,0, false);
			eraseObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_ERASE_ABLE_0,0, false);
			if((colObj = $FF or eraseObj <> $FF) and ((controlList[controlId].b_controlPressUp = false and controlList[controlId].b_controlPressLeft = true) and (grounded = true))) then moveDir := @LEFT;  //TODO: AnimationWalkL
		
			colObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_COLLIDE_ABLE_0,0, false);
			eraseObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_ERASE_ABLE_0,0, false);
			if((colObj = $FF or eraseObj <> $FF) and (controlList[controlId].b_controlPressRight = true and grounded = true)) then moveDir := @RIGHT;
						
			if(moveDir = $FF) then begin
				colObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_ERASE_ABLE_0,0, false);
				colObj2 := GetObjArea(id, objectList[id].transZ, 0, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj2 := GetObjArea(id, objectList[id].transZ, 0, @COMP_ERASE_ABLE_0,0, false);
				if((colObj = $FF or eraseObj <> $FF) and (colObj2 = $FF or eraseObj2 <> $FF)) then begin
					if(controlList[controlId].b_controlPressLeft = true or controlList[controlId].controlFollowKeyLeft = true) then begin
						if(grounded = true) then begin 
							moveDir := @UP_LEFT;
							controlList[controlId].controlFollowKeyLeft := false;
						end;
					end;
				end; 
				colObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_ERASE_ABLE_0,0, false);
				colObj2 := GetObjArea(id, objectList[id].transZ, 2, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj2 := GetObjArea(id, objectList[id].transZ, 2, @COMP_ERASE_ABLE_0,0, false);
				if((colObj = $FF or eraseObj <> $FF) and (colObj2 = $FF or eraseObj2 <> $FF)) then begin
					if(controlList[controlId].b_controlPressRight = true or controlList[controlId].controlFollowKeyRight = true) then begin
						if(grounded = true) then begin 
							moveDir := @UP_RIGHT;
							controlList[controlId].controlFollowKeyRight := false;
						end;
					end;
				end; 
			end;
			
			if(moveDir = $FF) then begin
				colObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_ERASE_ABLE_0,0, false);
				
				if((colObj = $FF or eraseObj <> $FF) and (controlList[controlId].b_controlPressUp = true and grounded = true)) then begin 
					controlList[controlId].controlState := @CTRL_STATE_JUMP;
					controlList[controlId].controlJumpStep := 0;
					objectList[id].b_physFallDown := false; 
				end;

				colObj := GetObjArea(id, objectList[id].transZ, 7, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj := GetObjArea(id, objectList[id].transZ, 7, @COMP_ERASE_ABLE_0,0, false);
				if((colObj = $FF or eraseObj <> $FF) and (controlList[controlId].b_controlPressDown = true and grounded = true)) then begin 
					moveDir := @DOWN;
				end;
			end; 
		end;
		if(moveDir = @LEFT or moveDir = @UP_LEFT) then SwitchAnimation(id, @ANIM_WALK_L)
		else if(moveDir = @RIGHT or moveDir = @UP_RIGHT) then SwitchAnimation(id, @ANIM_WALK_R)
//		else if(moveDir = $FF) then SwitchAnimation(id, @ANIM_STAND);
    end
    else if(controlList[controlId].controlState = @CTRL_STATE_JUMP) then begin
	    if(controlList[controlId].controlJumpStep = 0) then moveDir := @UP			// TODO: check for collideable?
	    else if(controlList[controlId].controlJumpStep = 1 or controlList[controlId].controlJumpStep = 2) then begin
			colObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_DESTROY_COLLIDE_0,0, false);
			if((colObj <> $FF and controlList[controlId].b_controlPressLeft = true)) then DamageCollide(colObj);
			
			colObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_DESTROY_COLLIDE_0,0, false);
			if((colObj <> $FF and controlList[controlId].b_controlPressRight = true)) then DamageCollide(colObj);

		    	colObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_COLLIDE_ABLE_0,0, false);
			eraseObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_ERASE_ABLE_0,0, false);
			if((colObj = $FF or eraseObj <> $FF) and (controlList[controlId].b_controlPressLeft = true)) then moveDir := @LEFT;  //TODO: AnimationWalkL
		
			colObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_COLLIDE_ABLE_0,0, false);
			eraseObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_ERASE_ABLE_0,0, false);
			if((colObj = $FF or eraseObj <> $FF) and (controlList[controlId].b_controlPressRight = true)) then moveDir := @RIGHT;  //TODO: AnimationWalkR


			if(moveDir = $FF) then begin
				colObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_ERASE_ABLE_0,0, false);
				colObj2 := GetObjArea(id, objectList[id].transZ, 0, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj2 := GetObjArea(id, objectList[id].transZ, 0, @COMP_ERASE_ABLE_0,0, false);
				if((colObj = $FF or eraseObj <> $FF) and (colObj2 = $FF or eraseObj2 <> $FF)) then begin
					if(controlList[controlId].b_controlPressLeft = true) then begin
						moveDir := @UP_LEFT;
					end;
				end; 
				colObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_ERASE_ABLE_0,0, false);
				colObj2 := GetObjArea(id, objectList[id].transZ, 2, @COMP_COLLIDE_ABLE_0,0, false);
				eraseObj2 := GetObjArea(id, objectList[id].transZ, 2, @COMP_ERASE_ABLE_0,0, false);
				if((colObj = $FF or eraseObj <> $FF) and (colObj2 = $FF or eraseObj2 <> $FF)) then begin
					if(controlList[controlId].b_controlPressRight = true) then begin
						moveDir := @UP_RIGHT;
					end;
				end; 
			end;
	    end;
	    inc(controlList[controlId].controlJumpStep);
		if(controlList[controlId].controlJumpStep >= 3) then begin 
			controlList[controlId].controlState := @CTRL_STATE_WALK;
			objectList[id].b_physFallDown := true;
		end;
		if(moveDir = @LEFT or moveDir = @UP_LEFT) then SwitchAnimation(id, @ANIM_WALK_L)
		else if(moveDir = @RIGHT or moveDir = @UP_RIGHT) then SwitchAnimation(id, @ANIM_WALK_R)
		else if(moveDir = $FF) then SwitchAnimation(id, @ANIM_STAND);
	end 
	else if((controlList[controlId].controlState = @CTRL_STATE_SWIM or controlList[controlId].controlState = @CTRL_STATE_CLIMB) or controlList[controlId].controlState = @CTRL_STATE_ROBE) then begin
		colObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_DESTROY_COLLIDE_0,0, false);
		if(colObj <> $FF and controlList[controlId].b_controlPressLeft = true) then DamageCollide(colObj);
		
		colObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_DESTROY_COLLIDE_0,0, false);
		if(colObj <> $FF and controlList[controlId].b_controlPressRight = true) then DamageCollide(colObj);
		
		colObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_DESTROY_COLLIDE_0,0, false);
		if(colObj <> $FF and controlList[controlId].b_controlPressUp = true) then DamageCollide(colObj);

		colObj := GetObjArea(id, objectList[id].transZ, 7, @COMP_DESTROY_COLLIDE_0,0, false);
		if(colObj <> $FF and controlList[controlId].b_controlPressDown = true) then DamageCollide(colObj);
		
		colObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_COLLIDE_ABLE_0,0, false);
		eraseObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_ERASE_ABLE_0,0, false);
		if((colObj = $FF or eraseObj <> $FF) and controlList[controlId].b_controlPressLeft) then moveDir := @LEFT;  //TODO: AnimationSwimL

		colObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_COLLIDE_ABLE_0,0, false);
		eraseObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_ERASE_ABLE_0,0, false);
		if((colObj = $FF or eraseObj <> $FF) and controlList[controlId].b_controlPressRight) then moveDir := @RIGHT;  //TODO: AnimationSwimR

		colObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_COLLIDE_ABLE_0,0, false);
		eraseObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_ERASE_ABLE_0,0, false);
		if((colObj = $FF or eraseObj <> $FF) and (controlList[controlId].b_controlPressUp and controlList[controlId].controlState <> @CTRL_STATE_ROBE)) then moveDir := @UP;  //TODO: AnimationSwimR
		
		colObj := GetObjArea(id, objectList[id].transZ, 7, @COMP_COLLIDE_ABLE_0,0, false);
		eraseObj := GetObjArea(id, objectList[id].transZ, 7, @COMP_ERASE_ABLE_0,0, false);
		if((colObj = $FF or eraseObj <> $FF) and (controlList[controlId].b_controlPressDown and controlList[controlId].controlState <> @CTRL_STATE_ROBE)) then moveDir := @DOWN;  //TODO: AnimationSwimR
		
		if(controlList[controlId].controlState = @CTRL_STATE_SWIM) then begin
			if(moveDir = @LEFT or moveDir = @UP) then SwitchAnimation(id, @ANIM_SWIM_L)
			else if(moveDir = @RIGHT or moveDir = @DOWN) then SwitchAnimation(id, @ANIM_SWIM_R);
		end
		else if(controlList[controlId].controlState = @CTRL_STATE_CLIMB) then begin
			if(moveDir <> $FF) then SwitchAnimation(id, @ANIM_CLIMB);
		end
		else if(controlList[controlId].controlState = @CTRL_STATE_ROBE) then begin
			if(moveDir <> $FF) then SwitchAnimation(id, @ANIM_ROBE);
		end;
	end;
	
	// Do Moves
	oldx := objectList[id].transX;
	oldy := objectList[id].transY;
	
	if(moveDir = @LEFT) then begin
		eraseObj := GetObjArea(id, objectList[id].transZ, 3, @COMP_ERASE_ABLE_0,0, false);
		if(eraseObj <> $FF) then DeletePos(eraseObj, false, false);
		shift := ConvertShift(gravity, 3);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @RIGHT) then begin
		eraseObj := GetObjArea(id, objectList[id].transZ, 5, @COMP_ERASE_ABLE_0,0, false);
		if(eraseObj <> $FF) then DeletePos(eraseObj, false, false);
		shift := ConvertShift(gravity, 5);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @UP_LEFT) then begin
		eraseObj := GetObjArea(id, objectList[id].transZ, 0, @COMP_ERASE_ABLE_0,0, false);
		eraseObj2 := GetObjArea(id, objectList[id].transZ, 3, @COMP_ERASE_ABLE_0,0, false);
		if(eraseObj <> $FF) then DeletePos(eraseObj, false, false);
		if(eraseObj2 <> $FF) then DeletePos(eraseObj2, false, false);
		shift := ConvertShift(gravity, 0);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @UP_RIGHT) then begin
		eraseObj := GetObjArea(id, objectList[id].transZ, 2, @COMP_ERASE_ABLE_0,0, false);
		eraseObj2 := GetObjArea(id, objectList[id].transZ, 5, @COMP_ERASE_ABLE_0,0, false);
		if(eraseObj <> $FF) then DeletePos(eraseObj, false, false);
		if(eraseObj2 <> $FF) then DeletePos(eraseObj2, false, false);
		shift := ConvertShift(gravity, 2);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @UP) then begin
		eraseObj := GetObjArea(id, objectList[id].transZ, 1, @COMP_ERASE_ABLE_0,0, false);
		if(eraseObj <> $FF) then DeletePos(eraseObj, false, false);
		shift := ConvertShift(gravity, 1);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @DOWN) then begin
		eraseObj := GetObjArea(id, objectList[id].transZ, 7, @COMP_ERASE_ABLE_0,0, false);
		if(eraseObj <> $FF) then DeletePos(eraseObj, false, false);
		shift := ConvertShift(gravity, 7);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end;
	if(newx <> $FF) then begin 
		CycleAnimation(id);
		SetPos(id,oldx, oldy, newx, newy, objectList[id].transZ);
	end;	
end;

