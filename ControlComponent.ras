procedure ReleaseKeys(id: byte);
var
	pg: pointer of gobject;

begin
	pg := #objectList[id];
	pg.controlPressLeft := false;
	pg.controlPressRight := false;
	pg.controlPressDown := false;			
	pg.controlPressUp := false;
	
end;

procedure ProcessBackObj(id: byte);
var
	pg: pointer of gobject;
	defWalk: boolean;
	gravity: byte;
	backObj, backObj2: byte;
begin
	// TODO: Check for portal component
	//	if (backObj == null || backObj.getPortalComponent() == null) {
	//		lastPortal = null;
	//	}	
	pg := #objectList[id];
	

	if(pg.components[0] & @COMP_PHYSICS_0 <> @COMP_PHYSICS_0) then gravity := @DOWN else gravity := pg.physGravity; 
	
	defWalk := true;
	
	backObj2 := GetObjArea(id, @Z_BACK2, 7, @COMP_WATER_0,0);

	if(backObj2 <> $FF or pg.controlPermanentSwim = true) then begin
		pg.controlJump := true;
		// TODO:Anim Swim
		pg.controlState := @CTRL_STATE_SWIM;
		defWalk := false;
	end;
	if(defWalk = true) then pg.controlState := @CTRL_STATE_WALK;

	
	
	
end;

procedure InputControl(id: byte);
var
	gravity: byte;
	pg: pointer of gobject;
begin
	pg := #objectList[id];
	if(pg.components[0] & @COMP_PHYSICS_0 <> @COMP_PHYSICS_0) then gravity := @DOWN else gravity := pg.physGravity;
	if(joy2 & joy_fire = joy_fire) then ReleaseKeys(id)
	else begin
		if(joy2 & joy_left = joy_left) then begin
			if(gravity = @DOWN) then pg.controlPressLeft := true;
			if(gravity = @UP) then pg.controlPressRight := true;
			if(gravity = @LEFT) then pg.controlPressDown := true;			
			if(gravity = @RIGHT) then pg.controlPressUp := true;			
		end;
		if(joy2 & joy_left <> joy_left) then begin
			if(gravity = @DOWN) then pg.controlPressLeft := false;
			if(gravity = @UP) then pg.controlPressRight := false;
			if(gravity = @LEFT) then pg.controlPressDown := false;			
			if(gravity = @RIGHT) then pg.controlPressUp := false;			
		end;
		if(joy2 & joy_right = joy_right) then begin
			if(gravity = @DOWN) then pg.controlPressRight := true;
			if(gravity = @UP) then pg.controlPressLeft := true;
			if(gravity = @LEFT) then pg.controlPressUp := true;			
			if(gravity = @RIGHT) then pg.controlPressDown := true;
		end;
		if(joy2 & joy_right <> joy_right) then begin
			if(gravity = @DOWN) then pg.controlPressRight := false;
			if(gravity = @UP) then pg.controlPressLeft := false;
			if(gravity = @LEFT) then pg.controlPressUp := false;			
			if(gravity = @RIGHT) then pg.controlPressDown := false;			
		end;
		if(joy2 & joy_up = joy_up) then begin
			if(gravity = @DOWN) then pg.controlPressUp := true;
			if(gravity = @UP) then pg.controlPressDown := true;
			if(gravity = @LEFT) then pg.controlPressLeft := true;			
			if(gravity = @RIGHT) then pg.controlPressRight := true;
		end;
		if(joy2 & joy_up <> joy_up) then begin
			if(gravity = @DOWN) then pg.controlPressUp := false;
			if(gravity = @UP) then pg.controlPressDown := false;
			if(gravity = @LEFT) then pg.controlPressLeft := false;			
			if(gravity = @RIGHT) then pg.controlPressRight := false;
		end;
		if(joy2 & joy_down = joy_down) then begin
			if(gravity = @DOWN) then pg.controlPressDown := true;
			if(gravity = @UP) then pg.controlPressUp := true;
			if(gravity = @LEFT) then pg.controlPressRight := true;			
			if(gravity = @RIGHT) then pg.controlPressLeft := true;
		end;
		if(joy2 & joy_down <> joy_down) then begin
			if(gravity = @DOWN) then pg.controlPressDown := false;
			if(gravity = @UP) then pg.controlPressUp := false;
			if(gravity = @LEFT) then pg.controlPressRight := false;			
			if(gravity = @RIGHT) then pg.controlPressLeft := false;
		end;
	end;
end;

procedure UpdateControl(id: byte);
var
	pg,ps: pointer of gobject;
	grounded: boolean;
	isShift: boolean;
	gravity: byte;
	oldx, oldy, newx, newy, moveDir: byte; 

	shift: integer;

	colObj, eraseObj, colObj2, eraseObj2: byte;
	shiftDir: byte;
begin
	pg := #objectList[id];

	moveDir := $FF;
	grounded := false;
	isShift := false;
	shift := 0;
	shiftDir := $FF;
	gravity := $FF;
	newx := $FF;
	newy := $FF;
	
	
	if(pg.components[0] & @COMP_PHYSICS_0 <> @COMP_PHYSICS_0) then begin
		grounded := true;
		isShift := false;
		gravity := @DOWN;
	end
	else begin
		colObj := GetObjArea(id, pg.transZ, 7, @COMP_COLLIDE_ABLE_0,0);
		if(colObj <> $FF) then begin 
			grounded := true;
			ps := #objectList[colObj];
			shiftDir := ps.shiftDir;
			gravity := pg.physGravity;
			if ((gravity = @DOWN and shiftDir = @LEFT) or (gravity = @DOWN and shiftDir = @RIGHT)) then isShift:= true;
			if ((gravity = @LEFT and shiftDir = @UP) or (gravity = @LEFT and shiftDir = @DOWN)) then isShift:= true; 
			if ((gravity = @UP and shiftDir = @LEFT) or  (gravity = @UP and shiftDir = @RIGHT)) then isShift:= true;
			if ((gravity = @RIGHT and shiftDir = @LEFT) or (gravity = @RIGHT and shiftDir = @RIGHT)) then isShift := true;
		end;
	end;
	
	if(pg.controlState = @CTRL_STATE_WALK) then begin
		if(isShift = false) then begin
			colObj := GetObjArea(id, pg.transZ, 3, @COMP_DESTROY_COLLIDE_0,0);
			if((colObj <> $FF and pg.controlPressLeft = true) and (pg.controlPressUp = false and grounded = true)) then DamageCollide(colObj);
			
			colObj := GetObjArea(id, pg.transZ, 5, @COMP_DESTROY_COLLIDE_0,0);
			if((colObj <> $FF and pg.controlPressRight = true) and (pg.controlPressUp = false and grounded = true)) then DamageCollide(colObj);
			
			colObj := GetObjArea(id, pg.transZ, 7, @COMP_DESTROY_COLLIDE_0,0);
			if((colObj <> $FF and pg.controlPressDown = true) and grounded = true) then DamageCollide(colObj);
			
			colObj := GetObjArea(id, pg.transZ, 3, @COMP_COLLIDE_ABLE_0,0);
			eraseObj := GetObjArea(id, pg.transZ, 3, @COMP_ERASE_ABLE_0,0);
			if((colObj = $FF or eraseObj <> $FF) and ((pg.controlPressUp = false and pg.controlPressLeft = true) and (grounded = true))) then moveDir := @LEFT;  //TODO: AnimationWalkL

		
			colObj := GetObjArea(id, pg.transZ, 5, @COMP_COLLIDE_ABLE_0,0);
			eraseObj := GetObjArea(id, pg.transZ, 5, @COMP_ERASE_ABLE_0,0);
			if((colObj = $FF or eraseObj <> $FF) and (pg.controlPressRight = true and grounded = true)) then moveDir := @RIGHT;  //TODO: AnimationWalkR
			
			if(moveDir = $FF) then begin
			
				colObj := GetObjArea(id, pg.transZ, 1, @COMP_COLLIDE_ABLE_0,0);
				eraseObj := GetObjArea(id, pg.transZ, 1, @COMP_ERASE_ABLE_0,0);
				colObj2 := GetObjArea(id, pg.transZ, 0, @COMP_COLLIDE_ABLE_0,0);
				eraseObj2 := GetObjArea(id, pg.transZ, 0, @COMP_ERASE_ABLE_0,0);
				if((colObj = $FF or eraseObj <> $FF) and (colObj2 = $FF or eraseObj2 <> $FF)) then begin
					if(pg.controlPressLeft = true or pg.controlFollowKeyLeft = true) then begin
						if(grounded = true or pg.controlJump = true) then begin 
							moveDir := @UP_LEFT;
							pg.controlFollowKeyLeft := false;
						end;
					end;
				end; 
				colObj := GetObjArea(id, pg.transZ, 1, @COMP_COLLIDE_ABLE_0,0);
				eraseObj := GetObjArea(id, pg.transZ, 1, @COMP_ERASE_ABLE_0,0);
				colObj2 := GetObjArea(id, pg.transZ, 2, @COMP_COLLIDE_ABLE_0,0);
				eraseObj2 := GetObjArea(id, pg.transZ, 2, @COMP_ERASE_ABLE_0,0);
				if((colObj = $FF or eraseObj <> $FF) and (colObj2 = $FF or eraseObj2 <> $FF)) then begin
					if(pg.controlPressRight = true or pg.controlFollowKeyRight = true) then begin
						if(grounded = true or pg.controlJump = true) then begin 
							moveDir := @UP_RIGHT;
							pg.controlFollowKeyRight := false;
						end;
					end;
				end; 
			end;
			
			if(moveDir = $FF) then begin
				colObj := GetObjArea(id, pg.transZ, 1, @COMP_COLLIDE_ABLE_0,0);
				eraseObj := GetObjArea(id, pg.transZ, 1, @COMP_ERASE_ABLE_0,0);
				
				if((colObj = $FF or eraseObj <> $FF) and (pg.controlPressUp = true and grounded = true)) then begin 
					moveDir := @UP;
					pg.controlJump := true;
				end;

				colObj := GetObjArea(id, pg.transZ, 7, @COMP_COLLIDE_ABLE_0,0);
				eraseObj := GetObjArea(id, pg.transZ, 7, @COMP_ERASE_ABLE_0,0);
				if((colObj = $FF or eraseObj <> $FF) and (pg.controlPressDown = true and grounded = true)) then begin 
					moveDir := @DOWN;
				end;
			end; 
		end;
		// TODO: Stand animation
		if(moveDir <> @UP and pg.components[0] & @COMP_PHYSICS_0 = @COMP_PHYSICS_0) then pg.controlJump := false;
    end
	else if(pg.controlState = @CTRL_STATE_SWIM) then begin
		colObj := GetObjArea(id, pg.transZ, 3, @COMP_DESTROY_COLLIDE_0,0);
		if(colObj <> $FF and pg.controlPressLeft = true) then DamageCollide(colObj);
		
		colObj := GetObjArea(id, pg.transZ, 5, @COMP_DESTROY_COLLIDE_0,0);
		if(colObj <> $FF and pg.controlPressRight = true) then DamageCollide(colObj);
		
		colObj := GetObjArea(id, pg.transZ, 1, @COMP_DESTROY_COLLIDE_0,0);
		if(colObj <> $FF and pg.controlPressUp = true) then DamageCollide(colObj);

		colObj := GetObjArea(id, pg.transZ, 7, @COMP_DESTROY_COLLIDE_0,0);
		if(colObj <> $FF and pg.controlPressDown = true) then DamageCollide(colObj);
		
		colObj := GetObjArea(id, pg.transZ, 3, @COMP_COLLIDE_ABLE_0,0);
		eraseObj := GetObjArea(id, pg.transZ, 3, @COMP_ERASE_ABLE_0,0);
		if((colObj = $FF or eraseObj <> $FF) and pg.controlPressLeft) then moveDir := @LEFT;  //TODO: AnimationSwimL

		colObj := GetObjArea(id, pg.transZ, 5, @COMP_COLLIDE_ABLE_0,0);
		eraseObj := GetObjArea(id, pg.transZ, 5, @COMP_ERASE_ABLE_0,0);
		if((colObj = $FF or eraseObj <> $FF) and pg.controlPressRight) then moveDir := @RIGHT;  //TODO: AnimationSwimR

		colObj := GetObjArea(id, pg.transZ, 1, @COMP_COLLIDE_ABLE_0,0);
		eraseObj := GetObjArea(id, pg.transZ, 1, @COMP_ERASE_ABLE_0,0);
		if((colObj = $FF or eraseObj <> $FF) and pg.controlPressUp) then moveDir := @UP;  //TODO: AnimationSwimR
		
		colObj := GetObjArea(id, pg.transZ, 7, @COMP_COLLIDE_ABLE_0,0);
		eraseObj := GetObjArea(id, pg.transZ, 7, @COMP_ERASE_ABLE_0,0);
		if((colObj = $FF or eraseObj <> $FF) and pg.controlPressDown) then moveDir := @DOWN;  //TODO: AnimationSwimR
	end;
	
	// Do Moves
	oldx := pg.transX;
	oldy := pg.transY;
	
	// Do Moves
	if(moveDir = @LEFT) then begin
		eraseObj := GetObjArea(id, pg.transZ, 3, @COMP_ERASE_ABLE_0,0);
		if(eraseObj <> $FF) then DeletePos(eraseObj);
		shift := ConvertShift(gravity, 3);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @RIGHT) then begin
		eraseObj := GetObjArea(id, pg.transZ, 5, @COMP_ERASE_ABLE_0,0);
		if(eraseObj <> $FF) then DeletePos(eraseObj);
		shift := ConvertShift(gravity, 5);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @UP_LEFT) then begin
		eraseObj := GetObjArea(id, pg.transZ, 0, @COMP_ERASE_ABLE_0,0);
		eraseObj2 := GetObjArea(id, pg.transZ, 3, @COMP_ERASE_ABLE_0,0);
		if(eraseObj <> $FF) then DeletePos(eraseObj);
		if(eraseObj2 <> $FF) then DeletePos(eraseObj2);
		shift := ConvertShift(gravity, 0);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @UP_RIGHT) then begin
		eraseObj := GetObjArea(id, pg.transZ, 2, @COMP_ERASE_ABLE_0,0);
		eraseObj2 := GetObjArea(id, pg.transZ, 5, @COMP_ERASE_ABLE_0,0);
		if(eraseObj <> $FF) then DeletePos(eraseObj);
		if(eraseObj2 <> $FF) then DeletePos(eraseObj2);
		shift := ConvertShift(gravity, 2);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @UP) then begin
		eraseObj := GetObjArea(id, pg.transZ, 1, @COMP_ERASE_ABLE_0,0);
		if(eraseObj <> $FF) then DeletePos(eraseObj);
		shift := ConvertShift(gravity, 1);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end
	else if(moveDir = @DOWN) then begin
		eraseObj := GetObjArea(id, pg.transZ, 7, @COMP_ERASE_ABLE_0,0);
		if(eraseObj <> $FF) then DeletePos(eraseObj);
		shift := ConvertShift(gravity, 7);
		newx := CalcPositionX(oldx, Hi(shift));
		newy := CalcPositionY(oldy, Lo(shift));
	end;

	if(newx <> $FF) then SetPos(id,oldx, oldy, newx, newy, pg.transZ);
	
	ProcessBackObj(id);
end;

