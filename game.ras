program game;

@startblock $0f00 "Variables"

var	
	//@define DEBUG 1
	@define OVERFLOW_CHECK 1
	@define USE_KERNAL 0

	// Charsets
	@define charsetLoc1 $3800
	@define charsetLoc2 $7800
	@define tilesetLoc1 $3000
	@define tilesetLoc2 $7000
	@define spriteLoc1  $2000
	@define spriteLoc2  $4800
	@define tilesetCol  $3a00
	// Automatically export charsets 
	@export "charsets/charset.flf" "charsets/charset.bin" 60	
 	@export "charsets/tileset.flf" "charsets/tileset.bin" 256	
	@export "sprites/spr.flf" "sprites/spr.bin" 4096	
  	charset1: incbin("charsets/charset.bin", @charsetLoc1);
  	charset2: incbin("charsets/charset.bin", @charsetLoc2);
  	tileset1: incbin("charsets/tileset.bin", @tilesetLoc1);
   	tileset2: incbin("charsets/tileset.bin", @tilesetLoc2);
  	sprite1: incbin("sprites/spr.bin", @spriteLoc1);
  	sprite2: incbin("sprites/spr.bin", @spriteLoc2);
	tilesetColors :  incbin("charsets/tileset_color.bin", @tilesetCol);
	
	// Double Buffer
	currentBank: byte=0;
	time: byte=0;
	globaltime: byte=0;
	frameStatus: byte;
	screen: byte;
	debugx: byte;
	countSprite: byte=0;
	
	// Game	
	@define SCENES_SIZE 1
	@define DIMX 20
	@define DIMY 12
	@define DIMZ 4
	@define MAX_OBJECTS 190
	@define MAX_LASER 30
	@define DIMTILES 240
	@define DIMANIMS 12
	@define Z_BACK2 3
	@define Z_BACK1 2
	@define Z_MAIN 1
	@define Z_FRONT 0
	@define UNKNOWN $FF
	@define DOWN 7
	@define UP 1
	@define LEFT 3
	@define RIGHT 5
	@define SHIFT_DOWN 4
	@define SHIFT_UP 5
	@define SHIFT_LEFT 6
	@define SHIFT_RIGHT 7
	@define DOWN_LEFT 6
	@define DOWN_RIGHT 8
	@define UP_LEFT 0
	@define UP_RIGHT 2
	@define STOP 12
	@define AREA_OUT $FF
	@define AREA_DOWN 0
	@define AREA_UP 1
	@define AREA_LEFT 2
	@define AREA_RIGHT 3
	@define AREA_CENTER 4
	@define LASER_STEP 4
	@define TURN_RIGHT 1
	@define TURN_LEFT 2
	@define TURN_THROUGH  3
	@define PUSHDIR 1
	@define PULLDIR $FF
	@define LASER_TYPE_USER 10 

	@define ANIM_MODE_FIX 0
	@define ANIM_MODE_LR 1
	@define ANIM_MODE_LR_REPEAT 2
	
	@define ANIM_WALK_L 0
	@define ANIM_WALK_R 1
	@define ANIM_STAND 2
	@define ANIM_SWIM_L 3
	@define ANIM_SWIM_R 4
	@define ANIM_CLIMB 5
	@define ANIM_ROBE 6
	@define ANIM_WATER_U 7
	@define ANIM_WATER_D 8
	@define ANIM_WATER_L 9
	@define ANIM_WATER_R 10
	@define ANIM_PORTAL 11
	
	collAreaUp: array[9] of byte = (8,7,6,5,4,3,2,1,0);
	collAreaLeft: array[9] of byte = (2,5,8,1,4,7,0,3,6);
	collAreaRight: array[9] of byte = (6,3,0,7,4,1,8,5,2);

	shiftAreaDownX: array[9] of byte = (-1, 0, 1 , -1, 0, 1, -1, 0, 1);
	shiftAreaUpX: array[9] of byte = (1, 0, -1, 1, 0, -1, 1, 0, -1);
	shiftAreaLeftX: array[9] of byte = (1, 1, 1, 0, 0, 0, -1, -1, -1);
	shiftAreaRightX: array[9] of byte = (-1, -1, -1,0, 0, 0, 1, 1, 1);

	shiftAreaDownY: array[9] of byte = (-1, -1, -1, 0, 0, 0, 1, 1, 1);
	shiftAreaUpY: array[9] of byte = ( 1, 1, 1 , 0, 0, 0, -1, -1, -1);
	shiftAreaLeftY: array[9] of byte = ( -1, 0, 1, -1, 0, 1, -1, 0, 1);
	shiftAreaRightY: array[9] of byte = ( 1, 0, -1,  1, 0, -1, 1, 0, -1);
	
	tempPointer: pointer of byte;
	
	@define ID_TEXTBOX 128
	@define ID_IMAGEBOX 129
	@define ID_MENU 130
	@define STATE_PLAY 0
	@define STATE_DO_NOTHING 1
	@define STATE_PAUSE_TAGS 2
	@define STATE_PAUSE_ALL 3
	
	@define DURATION_KILL 50
	
	@define SCRIPT_INIT 0
	@define SCRIPT_PLAY 1
	
	@define COMP_PHYSICS_0          %00000001
	@define COMP_COLLIDE_ABLE_0     %00000010
	@define COMP_SHIFT_PLATTFORM_0  %00000100	
	@define COMP_DESTROY_COLLIDE_0  %00001000
 	@define COMP_ERASE_ABLE_0       %00010000
 	@define COMP_WATER_0            %00100000
	@define COMP_ANIMATION_0	    %01000000	
	@define COMP_CONTROL_0		    %10000000
    @define COMP_PUSHPULL_1 	    %00000001
    @define COMP_CLIMB_ABLE_1 	    %00000010
    @define COMP_ROBE_ABLE_1 	    %00000100
    @define COMP_FLOATER_1 		    %00001000
	@define COMP_PORTAL_1 		    %00010000
	@define COMP_GRAVPAD_1		    %00100000
	@define COMP_LASER_1		   	%01000000
	@define COMP_MIRROR_1		    %10000000
	@define COMP_DESTROY_ABLE_2     %00000001
	@define COMP_LASERBEAN_2		   %00000010
	@define COMP_LASERTRANS_ABLE_2  %00000100
	@define COMP_LASERONCE_2        %00001000
	@define COMP_PORTAL_ACTIVATE_2  %00010000
 	// https://www.aivosto.com/articles/petscii.pdf
 	@define LEV_CHARACTER $40
	@define LEV_BRICK $61
	@define LEV_STONE $62
	@define LEV_SAND $73
	@define LEV_WATER $3d
	@define LEV_WATER_UP $27
	@define LEV_WATER_DOWN $26
	@define LEV_WATER_LEFT $7b
	@define LEV_WATER_RIGHT $7d
	@define LEV_SHIFT_DOWN $59
	@define LEV_SHIFT_UP $5E
	@define LEV_SHIFT_LEFT $3C
	@define LEV_SHIFT_RIGHT $3E
	@define LEV_LADDER $68
	@define LEV_ROBE_DOWN $5f
	@define LEV_ROBE_UP $2d
	@define LEV_ROBE_LEFT $21
	@define LEV_ROBE_RIGHT $7C
	@define LEV_LADDER $68
	@define LEV_PORTAL $6F
	@define LEV_GRAVPAD_DOWN $32
	@define LEV_GRAVPAD_UP $38
	@define LEV_GRAVPAD_LEFT $34
	@define LEV_GRAVPAD_RIGHT $36
	@define LEV_MIRROR_LEFT $6e
	@define LEV_MIRROR_RIGHT $6d
	@define LEV_GLASS $67
	@define LEV_LASER_TRANSPORT $74
	@define LEV_LASER_TRANSPORT_ONCE $75
	@define LEV_PUSH_BOX $64
	@define LEV_PULL_BOX $65
	@define LEV_PORTAL_ACTIVATE  $63
	
	@define CTRL_STATE_WALK 0
	@define CTRL_STATE_CLIMB 1
	@define CTRL_STATE_ROBE 2
	@define CTRL_STATE_SWIM 3
	@define CTRL_STATE_JUMP 4
	
	
//	lev0: string = ("^>aa<ao  ao ao ao aaa   a aa  a  aa o  aao    aaa  aa o  @ aaa a  o o o o  ^ ^Yaao        ^    o ^Yaa      ^   oo o  ^Yaa     ^  o o o o ^Yaa    o o o o o     aa  o o o o o       aa                  aa                  aa                  aa");
    lev0: string = ("}}}}}}}}}a  a  a  aaa   a aa  a  aa    aa6    aaa  aa      aaa a      2    ^ ^Yaa     o   ^      ^Yaa      ^         ^Yaa     ^          ^Yaa             h    aa   ------====hh   aa mn    @ b    =  4aa   ====ss ss8 h o aaaa    aaaaaaaaaaa aa");
//	lev0: string = ("    ccccccccccccc                                               @                                          t u        Yaa     ^  b b b b ^Yaa    b b b b b     aa  b b b b b   o   aa        d e o     aa   n d  gg  m  e  aaaaaaaaaaaaaaaaaaaaaa");
	countObjects: byte;
	deletedObjects: Array[@MAX_OBJECTS] of byte;
	dynObjectList : Array[@MAX_OBJECTS] of byte;
	animObjectList : Array[@MAX_OBJECTS] of byte;
	countDyn: byte = 0;
	countAnim: byte = 0;
	mapback2 : Array[@DIMTILES] of byte;
	mapback1 : Array[@DIMTILES] of byte;
	mapmain : Array[@DIMTILES] of byte;
	mapfront : Array[@DIMTILES] of byte;
	portals: Array [2] of byte;
	lastPortal: byte;
	state, oldState: byte;
	killDuration, killTimer: byte;
	newSceneAfterKill: boolean;
	pa: pointer of byte;
	waitRelease, release: boolean;

	@define ANIM_CONSIDER_GRAV_IGNORE 0
	@define ANIM_CONSIDER_GRAV_FULL 1
	@define ANIM_CONSIDER_GRAV_HALF 2
	
	animObject = class
		animSeq: array[4] of byte;
		considerGravity: byte;
		size: byte;
		speed: byte;
		mode: byte;
	end;
	animList : Array[@DIMANIMS] of animObject;

@endblock

@startblock $e000 "Objects"
	gobject = record
		component0, component1, component2, component3: byte;
		
		// TransformTile
		transX, transY, transZ: byte;
	
		// Render
//		rendLastXpos, rendLastYpos, rendLastPathElem, rendMoveoffsetx, rendMoveoffsety, rendCenterX, rendCentery: byte;
//		rendEnergyX, rendEnergyY, rendEnergyPercent: byte; 
		rendTilePos: byte;
		b_rendAsSprite: byte;
		rendSpriteNum: byte;
		
		// Physics
		physGravity: byte;
		b_physFallDown: byte;
		b_physRollLeftRight, b_physHighFall: byte;

		// ShiftPlattform
		shiftDir: byte;
		
		// Control
		controlJumpStep: byte;
		controlState: byte;
		controlHasMoved: byte;
		b_controlPermanentSwim: byte;
		controlFollowKeyRight, controlFollowKeyLeft: byte;
		b_controlPressLeft, b_controlPressRight, b_controlPressUp, b_controlPressDown: byte;  // TODO: bit flag
		controlLastPortal: byte;
		// DestroyCollide
//		destColIgnoreTag: byte;
//		destColDamageEnergy: byte;
//		destColKey: byte;
		
		// Water
		waterFloaterDir: byte;
				
		// Animation
		animId: byte;
		animPos: byte;
		animFinish: byte;
		

		// Portal
		portalFireExitDir: byte;
		
		// Laser
		laserDir: byte;
		lastLaserDir: byte;
		b_laserWaitRelease: byte;
		b_laserRelease: byte;
 		laserLastTransportAble: byte;
 		laserType : byte;
 		laserTag: byte;
 //		b_laserIsSwitchReverse: byte;
		currentLaser: byte; 		
 		
		// Mirror
 		mirrorTurn: byte;
		
		// PushPull
		pushPullDir: byte;
	end;
	objectList : Array[@MAX_OBJECTS] of gobject;
@endblock

@startblock $7a00 "Code"

procedure Init();
begin
	state := @STATE_PLAY;
	oldState := 255;
	killDuration := 0;
	killTimer := 0;
	newSceneAfterKill := true;
	countObjects := 0;
	countDyn := 0;
	countAnim := 0;
	waitRelease := false;
	release := false;
end;

procedure print2x2block(x,y,c: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x = $FF or y = $FF) then SCREEN_BG_COL:=BROWN;
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	moveto(x*2,y*2,screen);
	screenmemory[0]:=c;
	screenmemory[1]:=c+1;
	screenmemory[40]:=c+40;
	screenmemory[41]:=c+41;

	moveto(x*2,y*2,hi(SCREEN_COL_LOC));
	screenmemory[0]:=tilesetColors[c]+8;
	screenmemory[1]:=tilesetColors[c+1]+8;
	screenmemory[40]:=tilesetColors[c+40]+8;;
	screenmemory[41]:=tilesetColors[c+41]+8;;
end;

procedure PrintText(x: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= 40) then SCREEN_BG_COL:=BLUE;
	@ENDIF
	
	moveto(0,24,screen);
	fillfast(screenmemory,$20,40);
	screenmemory[0]:=$1c;
	screenmemory[39]:=$1d;
	moveto(x,24,screen);
	printstring("HELLO",0,40);		
end;

procedure PrintSprite(x: byte, y: byte, spriteLoc: byte, num: byte);
var
	xs: integer;
	ys: byte;
	ns: byte;
begin
	xs := 24 + (x shl 4);
	ys := 50 + (y shl 4);
	if(currentBank = 0) then begin
		ns := spriteLoc + $80;
		SetSpriteLoc(num, ns, 0);
	end
	else begin
		ns := spriteLoc + $20;
		SetSpriteLoc(num, ns, 1);
	end;
	SpritePos(xs,ys,num);
end;

procedure PrintSpriteEmpty(i: byte, num: byte);
var
	ns: byte;
begin
	if(currentBank = 0) then begin
		ns := num + $80;
		SetSpriteLoc(i, ns, 0);
	end
	else begin
		ns := num;
		SetSpriteLoc(i, ns, 1);
	end;
	SpritePos(0,0,i);
end;


procedure print2x2blockEmpty(x,y:byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= @DIMX or y >= @DIMY) then SCREEN_BG_COL:=GREY;
	@ENDIF
	moveto(x*2,y*2,screen);
	screenmemory[0]:=255;
	screenmemory[1]:=255;
	screenmemory[40]:=255;
	screenmemory[41]:=255;
end;

procedure GetZLayerPointer(z: byte);
begin
	case z of
		@Z_BACK2: tempPointer := #mapback2;
		@Z_BACK1: tempPointer := #mapback1;
		@Z_MAIN: tempPointer := #mapmain;
		@Z_FRONT: tempPointer := #mapfront;
	end;
end;

procedure PaintPos(pos: byte, considerAnimation: boolean);
var
	x,y: byte;
	t: byte;
	animId: byte;
	hideSprite: boolean;
	pa: pointer of animObject;
	currentTile: byte;
	gravity: byte;
	shiftAnim: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=BROWN;
	@ENDIF
	
	x := mod(pos,@DIMX);
	y := pos / @DIMX;
	t := $FF;
	currentTile := $FF;
	hideSprite:= false;

 	if(mapfront[pos] <> 255) then begin
	 	t := mapfront[pos];
	 	hideSprite := true;
 	end
 	else if(mapmain[pos] <> 255) then begin
	 	t := mapmain[pos];
 	end
 	else if(mapback1[pos] <> 255) then begin
	 	t := mapback1[pos];
 	end
	else if(mapback2[pos] <> 255) then begin
	 	t := mapback2[pos];
 	end;
	
 	if(t <> 255) then begin
	 	animId := objectList[t].animId;
		pa := #animList[animId];
	 	if(considerAnimation = true and (objectList[t].component0 & @COMP_ANIMATION_0 = @COMP_ANIMATION_0)) then begin
			if(pa.considerGravity = @ANIM_CONSIDER_GRAV_IGNORE) then shiftAnim := 0
			else if(pa.considerGravity = @ANIM_CONSIDER_GRAV_FULL) then begin
				gravity := @DOWN;
				if((objectList[t].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[t].physGravity;
				if(gravity = @UP) then shiftAnim := 1
				else if(gravity = @RIGHT) then shiftAnim := 2
				else if(gravity = @LEFT) then shiftAnim := 3;
			end
			else if(pa.considerGravity = @ANIM_CONSIDER_GRAV_HALF) then begin
				gravity := @DOWN;
				if((objectList[t].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[t].physGravity;
				if(gravity = @UP) then shiftAnim := 1
				else if(gravity = @RIGHT) then shiftAnim := 0
				else if(gravity = @LEFT) then shiftAnim := 1;
			end;
			currentTile := pa.animSeq[objectList[t].animPos];
			currentTile := currentTile + shiftAnim;
			if(pa.mode = @ANIM_MODE_FIX) then objectList[t].animPos := 0
			else if(pa.mode = @ANIM_MODE_LR and objectList[t].animFinish = false) then begin
				if(objectList[t].animPos = pa.size - 1) then begin
					objectList[t].animPos := 0;
					objectList[t].animFinish := true;
				end
				else if(mod(globaltime, pa.speed) = 0) then inc(objectList[t].animPos);
			end
			else if(pa.mode = @ANIM_MODE_LR_REPEAT) then begin
				if(objectList[t].animPos = pa.size - 1) then begin
					objectList[t].animPos := 0;
					objectList[t].animFinish := false;
				end
				else if(mod(globaltime, pa.speed) = 0) then inc(objectList[t].animPos);
			end;				
		end
		else currentTile := objectList[t].rendTilePos;
		
	 	if(objectList[t].b_rendAsSprite = true and hideSprite = false) then begin
		 	PrintSprite(x,y,currentTile,objectList[t].rendSpriteNum)
		 end
	 	else
	 		print2x2block(x,y,currentTile);
	end
	else print2x2blockEmpty(x,y);
end;

function ConvertShift(gravity: byte, pos: byte) : integer;
var 
    ret: integer;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= 9) then SCREEN_BG_COL:=RED;
		if(gravity = $FF) then SCREEN_BG_COL:=RED;
	@ENDIF
	if(gravity = @DOWN) then ret := CreateInteger(shiftAreaDownX[pos],shiftAreaDownY[pos])
 	else if(gravity = @UP) then ret := CreateInteger(shiftAreaUpX[pos],shiftAreaUpY[pos])
 	else if(gravity = @LEFT) then ret := CreateInteger(shiftAreaLeftX[pos],shiftAreaLeftY[pos])
 	else if(gravity = @RIGHT) then ret := CreateInteger(shiftAreaRightX[pos],shiftAreaRightY[pos]);
    ConvertShift := ret; 	
end;


function CalcPosition(startx,starty, pos: byte) : integer;
var
	destx, desty: byte;
begin
	destx := startx + shiftAreaDownX[pos];
	desty := starty + shiftAreaDownY[pos];
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPosition := CreateInteger(destx, desty); 
end;


function CalcPositionMapPos(startx,starty, pos: byte) : byte;
var 
	npos: integer;
	ret: byte;
begin
	npos := CalcPosition(startx,starty, pos);
	CalcPositionMapPos := hi(npos) + lo(npos) * @DIMX;
end;

function GetObjectByPosFilterComp(x: byte, y: byte, z: byte, comp: byte, compIdx: byte) : byte;
var
	mapPos, colId, ret, val: byte;
begin
	GetZLayerPointer(z);
	ret := $FF;
	mapPos := x + y * @DIMX;
	@IFDEF OVERFLOW_CHECK
		if(mapPos >= @DIMTILES) then SCREEN_BG_COL:=LIGHT_RED;
	@ENDIF

	colId := tempPointer[mapPos];
	if(colId <> $FF) then begin
		case compIdx of
	        0: val := objectList[colId].component0 & comp;
	        1: val := objectList[colId].component1 & comp;
	        2: val := objectList[colId].component2 & comp;
	        4: val := objectList[colId].component3 & comp;
    		end;
		if(val = comp) then ret := colId;
	end;

	GetObjectByPosFilterComp := ret;
end;

function GetObjArea(id: byte, z: byte, pos:byte, comp: byte, compIdx: byte, b_norm: byte) : byte;
var
	gravity: byte;
	mapPos, colId, ret, val, gpos: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(id >= @MAX_OBJECTS) then SCREEN_BG_COL:=LIGHT_GREY;
	@ENDIF
	gravity := @DOWN;
	if(b_norm = false) then begin
		if((objectList[id].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[id].physGravity;

		if(objectList[id].physGravity = @DOWN) then gpos := pos
		else if(objectList[id].physGravity = @UP) then gpos := collAreaUp[pos] 
		else if(objectList[id].physGravity = @LEFT) then gpos := collAreaLeft[pos] 
		else if(objectList[id].physGravity = @RIGHT) then gpos := collAreaRight[pos]
	end
	else gpos := pos;

	GetZLayerPointer(z);

	mapPos := CalcPositionMapPos(objectList[id].transX, objectList[id].transY, gpos);
	colId := tempPointer[mapPos];
	ret := $FF;
	if(colId <> $FF) then begin
		case compIdx of
	        0: val := objectList[colId].component0 & comp;
	        1: val := objectList[colId].component1 & comp;
	        2: val := objectList[colId].component2 & comp;
	        4: val := objectList[colId].component3 & comp;
    		end;
		if(val = comp) then ret := colId;
	end;
	GetObjArea := ret;
end;


function CalcPositionX(startx,offsetx: byte) : byte;
var
	destx: byte;
begin
	destx := startx + offsetx;
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	CalcPositionX := destx;
end;

function CalcPositionY(starty,offsety: byte) : byte;
var
	desty: byte;
begin
	desty := starty + offsety;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPositionY := desty;
end;

procedure ChangeMapItem(id: byte, oldx: byte, oldy: byte, x: byte, y: byte, z:byte);
var
	oldpos: byte;
	pos: byte;
begin
	oldpos := oldx + oldy * @DIMX;
	pos := x + y * @DIMX;
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
		if(oldpos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	tempPointer[oldpos] := $FF;
	tempPointer[pos] := id;
	PaintPos(oldpos, false);
	PaintPos(pos, false);
end;

procedure UpdateMapItem(id: byte, x: byte, y: byte);
var
	oldpos: byte;
	pos: byte;
begin
	pos := x + y * @DIMX;
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	PaintPos(pos, true);
end;

procedure SetPos(i: byte,oldx:byte, oldy:byte, x: byte, y: byte, z: byte);
var
	pos: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(i >= @MAX_OBJECTS) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	pos := x + y * @DIMX;
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	GetZLayerPointer(z);
	
	if(oldx <> x or oldy <> y) then begin
		objectList[i].controlHasMoved := true; 

		ChangeMapItem(i, oldx, oldy, x, y, z);
		objectList[i].transX := x;
		objectList[i].transY := y;
	end;
end;

procedure AddMapItem(Id: byte, x: byte, y: byte, z:byte);
var
	pos: byte;
begin
	pos := x + y * @DIMX;
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	tempPointer[pos] := Id;
end;

procedure ClearMap();
var 
	m: byte;
begin
    for m := 0 to @DIMTILES do	
	begin
 	 	mapback2[m] := 255;
 	 	mapback1[m] := 255;
 	 	mapmain[m] := 255;
 	 	mapfront[m] := 255;
 	end;
	portals[0] := $FF;
	portals[1] := $FF;
end;

procedure AddDynItem(i: byte);
begin
	dynObjectList[countDyn] := i;
	inc(countDyn);
end;

procedure AddAnimItem(i: byte);
begin
	animObjectList[countAnim] := i;
	inc(countAnim);
end;

function GetId() : byte;
var
	ret: byte;
begin
    if (countObjects = @MAX_OBJECTS) then	 ret := $FF
    	else begin	
		inc(countObjects);
		ret := deletedObjects[@MAX_OBJECTS - 1 - countObjects];
	end;

	GetId := ret;
end;

procedure PaintFull();
var
	i: byte;
begin
    for i := 0 to @DIMTILES do
	begin
		PaintPos(i, false);
	end;
end;

procedure DeleteMapItem(id: byte, x: byte, y: byte, z:byte);
var	
	pos: byte;
	pm: pointer of byte;
begin
	
	pos := x + y * @DIMX;	
	GetZLayerPointer(z); 

	tempPointer[pos] := 255;
end;

procedure DeleteDynObject(id: byte);
var	
	i,j: byte;	
	found: boolean;
begin
	i := 0;
	found := false;
	while (i < countDyn and found = false)  do
	begin
		if(dynObjectList[i] = id) then 
			found := true
		else
			inc(i);
	end;
	if(found = true) then begin
		dec(countDyn); 
		for j:= i to countDyn - 1 do begin
			dynObjectList[j] := dynObjectList[j+1];
		end;
	end;
end;



procedure DeleteAnimObject(id: byte);
var	
	i,j: byte;	
	found: boolean;
begin
	i := 0;
	found := false;
	while (i < countAnim and found = false) do
	begin
		if(animObjectList[i] = id) then 
			found := true
		else
			inc(i);
	end;
	if(found = true) then begin
		dec(countAnim); 
		for j:= i to countAnim - 1 do begin
			animObjectList[j] := animObjectList[j+1];
		end;
	end;
end;

	
procedure DeletePos(id: byte, isDyn, isAnim: byte);
var
	x,y: byte;
begin
	if(countObjects > 0) then begin
		deletedObjects[@MAX_OBJECTS - 1 - countObjects] := id;
		dec(countObjects);
		DeleteMapItem(id, objectList[id].transX, objectList[id].transY, objectList[id].transZ);
		if(isDyn = true) then DeleteDynObject(id); 
		if(isAnim = true) then DeleteAnimObject(id);
		PaintPos(objectList[id].transX + objectList[id].transY * @DIMX, false);
	end; 
end;	

procedure SwitchBank();
begin
	if (currentBank = 0) then 
	begin
		SetBank(VIC_BANK1);
		setcharsetlocation(@tilesetLoc2);
		screen := hi(screen_char_loc);
		currentBank := 1;
	end
	else 
	begin
		SetBank(VIC_BANK0);
		setcharsetlocation(@tilesetLoc1);
		screen := hi(screen_char_loc2);
		currentBank := 0;
	end;

end;



procedure DamageCollide(id: byte);
begin
	// TODO
end;

procedure SwitchAnimation(id: byte, anim: byte); 
begin
	if(objectList[id].animId <> anim) then begin
		objectList[id].animId := anim;
		objectList[id].animPos := 0;
		objectList[id].animFinish := false;
	end;
end;


@include "GObjects.ras"

@include "ControlComponent.ras"
@include "PhysComponent.ras"
@include "FloaterComponent.ras"
@include "LaserComponent.ras"

procedure UpdateObject(id: byte);
begin
	if(objectList[id].component1 & @COMP_LASER_1 = @COMP_LASER_1) then begin 
		UpdateLaser(id);
	end;
	if(objectList[id].component0 & @COMP_PHYSICS_0 = @COMP_PHYSICS_0) then begin
		UpdatePhysics(id);
		ProcessBackObj(id);
	end;
	if(objectList[id].component0 & @COMP_CONTROL_0 = @COMP_CONTROL_0) then begin 
		InputControl(id); 
		UpdateControl(id);
		ProcessBackObj(id);
	end;
	if(objectList[id].component1 & @COMP_FLOATER_1 = @COMP_FLOATER_1) then begin 
		UpdateFloater(id);
		ProcessBackObj(id);
	end;
	objectList[id].controlHasMoved := false;
end;

procedure Update();
var 
	i: byte;
	id: byte;
begin
	ReadJoy2();

	if(countDyn <> 0) then begin
		for i:=0 to countDyn do	begin
			id := dynObjectList[i];
			UpdateObject(id);
		end;
	end;
end;

procedure Animate();
var 
	i: byte;
	id: byte;
begin
	if(countAnim <> 0) then begin
		for i:=0 to countAnim do	begin
			id := animObjectList[i];
			UpdateMapItem(id, objectList[id].transX, objectList[id].transY); 
		end;
	end;
end;

interrupt RasterBottomText();

interrupt RasterTopLevel();
begin
	startirq(@USE_KERNAL);
	//poke(^$d418,0,31);
	setmulticolormode();
	setcharsetlocation(@tilesetLoc1);
	SCREEN_FG_COL:=BLACK;
	if(frameStatus = 1) then begin
		if(time = 0) then begin
			SwitchBank();
		end
		else if(time = 1 and currentBank = 0) then copyFullScreen(^$0400, ^$4400)
		else if(time = 1 and currentBank = 1) then copyFullScreen(^$4400, ^$0400)
	end;
	if(time = 2) then begin
      	frameStatus := 0;
    end;
    if(time < 4) then inc(time)
	else if(frameStatus = 1) then time:=0;
	RasterIRQ(RasterBottomText(), 242, @USE_KERNAL);
	closeIrq();
end;

interrupt RasterBottomText();
begin
	startirq(@USE_KERNAL);
	setregularcolormode();
	setcharsetlocation(@charsetLoc1);
	SCREEN_FG_COL:=WHITE;

	if(time = 2) then begin
		PrintText(4);
	end;
		
	RasterIRQ(RasterTopLevel(),20,@USE_KERNAL);
	closeIrq();
//	setcharsetandscreenlocation(@tilesetLoc1,$4400);
end;

procedure InitAnimations();
var
	pa: pointer of animObject;

begin
	// walk left
	// l            r            u            d
	// 00 01 02 03  04 05 06 07  08 09 0a 0b  0c 0d 0e 0f 

	// walk right
	// l            r            u            d
	// 10 11 12 13  14 15 16 17  18 19 1a 1b  1c 1d 1e 1f 

	// stand
	// l  r  u  d
	// 20 21 22 23
	
	// swim l
	// l     r     u     d
	// 24 25 26 27 24 25 26 27

	// swim r
	// l     r     u     d
	// 28 29 2a 2b 28 29 2a 2b

	// TODO	
	// climb
	// l     r     u     d
	// 2c 2d 2e 2f 30 31 32 33

	// TODO	
	// robe
	// l     r     u     d
	// 34 35 36 37 48 49 4a 4b

 
	
	pa := #animList[@ANIM_WALK_L];
	pa.animSeq[0] := $00;
	pa.animSeq[1] := $04;
	pa.animSeq[2] := $08;
	pa.animSeq[3] := $0c;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 4;
	pa.speed := 2;
	pa.mode := @ANIM_MODE_LR;

	pa := #animList[@ANIM_WALK_R];
	pa.animSeq[0] := $10;
 	pa.animSeq[1] := $14;
	pa.animSeq[2] := $18;
	pa.animSeq[3] := $1c;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 4;
	pa.speed := 2;
	pa.mode := @ANIM_MODE_LR;


	pa := #animList[@ANIM_STAND];
	pa.animSeq[0] := $20; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_SWIM_L];
	pa.animSeq[0] := $24; 
 	pa.animSeq[1] := $26;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 2;
	pa.mode := @ANIM_MODE_LR;

	pa := #animList[@ANIM_SWIM_R];
	pa.animSeq[0] := $28; 
 	pa.animSeq[1] := $2a;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 2;
	pa.mode := @ANIM_MODE_LR;

	pa := #animList[@ANIM_CLIMB];
	pa.animSeq[0] := $2c; 
 	pa.animSeq[1] := $2f;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 2;
	pa.mode := @ANIM_MODE_LR;

	pa := #animList[@ANIM_ROBE];
	pa.animSeq[0] := $34; 
 	pa.animSeq[1] := $36;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 2;
	pa.mode := @ANIM_MODE_LR;

	pa := #animList[@ANIM_WATER_U];
	pa.animSeq[0] := $14; 
 	pa.animSeq[1] := $16;
	pa.animSeq[2] := $18;
	pa.animSeq[3] := $1A;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_HALF;
	pa.size := 4;
	pa.speed := 3;
	pa.mode := @ANIM_MODE_LR_REPEAT;

	pa := #animList[@ANIM_WATER_D];
	pa.animSeq[0] := $1A; 
 	pa.animSeq[1] := $18;
	pa.animSeq[2] := $16;
	pa.animSeq[3] := $14;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_HALF;
	pa.size := 4;
	pa.speed := 3;
	pa.mode := @ANIM_MODE_LR_REPEAT;

	pa := #animList[@ANIM_WATER_L];
	pa.animSeq[0] := $0C; 
 	pa.animSeq[1] := $0E;
	pa.animSeq[2] := $10;
	pa.animSeq[3] := $12;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 3;
	pa.mode := @ANIM_MODE_LR_REPEAT;

	pa := #animList[@ANIM_WATER_R];
	pa.animSeq[0] := $12; 
 	pa.animSeq[1] := $10;
	pa.animSeq[2] := $0E;
	pa.animSeq[3] := $0C;
	pa.considerGravity := false;
	pa.size := 4;
	pa.speed := 3;
	pa.mode := @ANIM_MODE_LR_REPEAT;
	
	pa := #animList[@ANIM_PORTAL];
	pa.animSeq[0] := $A6; 
 	pa.animSeq[1] := $A8;
	pa.animSeq[2] := $AA;
	pa.animSeq[3] := $AC;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_LR_REPEAT;	

end;

procedure InitSprites();
var
	i:byte;
begin
	// Set all sprites to be multicolor
	sprite_multicolor:=$ff;
	// Set common sprite multicolor #1 
	sprite_multicolor_reg1:=dark_grey;
	// Set  common sprite multicolor #2 
	sprite_multicolor_reg2:=white;
	for i := 0 to 8 do begin 
		sprite_color[i]:=light_red;
		SpritePos(0,0,i);
	end;
	// Turn on sprite 0 (or @useSprite)
	sprite_bitmask := $FF;
//	togglebit(sprite_bitmask,0,1);
end;
@endblock

procedure InitMap();
var 
	i,x,y,c : byte;
begin
	ClearMap();
	countDyn := 0;
	countAnim := 0;

	for i:= 0 to @MAX_OBJECTS do begin
		deletedObjects[@MAX_OBJECTS - 1 - i] := i;
	end;	
	
	for i := 0 to @DIMTILES do
	begin
		c := lev0[i];
		x := mod(i,@DIMX);
		y := i / @DIMX;
		case c of
			@LEV_CHARACTER: InitCharacter(x,y);
			@LEV_BRICK: InitBrick(x, y);
			@LEV_STONE: InitStone(x, y);
			@LEV_WATER: InitWater(x, y);
			@LEV_WATER_UP: InitWaterFlow(x, y, 20, @UP, @ANIM_WATER_U);
			@LEV_WATER_DOWN: InitWaterFlow(x, y, 26, @DOWN, @ANIM_WATER_D);
			@LEV_WATER_LEFT: InitWaterFlow(x, y, 12, @LEFT, @ANIM_WATER_L);
			@LEV_WATER_RIGHT: InitWaterFlow(x, y, 18, @RIGHT, @ANIM_WATER_R);
			@LEV_SAND: InitSand(x, y);
			@LEV_SHIFT_UP: InitShiftPlattform(x, y,4,@UP);
			@LEV_SHIFT_DOWN: InitShiftPlattform(x, y,6,@DOWN);
			@LEV_SHIFT_RIGHT: InitShiftPlattform(x, y, 8,@RIGHT);
			@LEV_SHIFT_LEFT: InitShiftPlattform(x, y, 10,@LEFT);
			@LEV_LADDER: InitLadder(x,y);
			@LEV_ROBE_UP: InitRobe(x,y,100,@DOWN);
			@LEV_ROBE_DOWN: InitRobe(x,y,102,@UP);
			@LEV_ROBE_LEFT: InitRobe(x,y,104,@LEFT);
			@LEV_ROBE_RIGHT: InitRobe(x,y,106,@RIGHT);
			@LEV_PORTAL: InitPortal(x,y,@UP);
			@LEV_GRAVPAD_UP: InitGravPad(x,y,38,@UP);
			@LEV_GRAVPAD_DOWN: InitGravPad(x,y,80,@DOWN);
			@LEV_GRAVPAD_LEFT: InitGravPad(x,y,82,@LEFT);
			@LEV_GRAVPAD_RIGHT: InitGravPad(x,y,84,@RIGHT);
			@LEV_MIRROR_LEFT: InitMirror(x,y, 96, @TURN_LEFT);
			@LEV_MIRROR_RIGHT: InitMirror(x,y, 98, @TURN_RIGHT);
			@LEV_GLASS: InitMirror(x,y,36, @TURN_THROUGH);
			@LEV_LASER_TRANSPORT: InitLaserTransport(x,y);
			@LEV_LASER_TRANSPORT_ONCE: InitLaserTransportOnce(x,y);
			@LEV_PUSH_BOX: InitBox(x,y, 162 , 1);
			@LEV_PULL_BOX: InitBox(x,y, 164 , -1);
			@LEV_PORTAL_ACTIVATE: InitPortalActivate(x,y);
		end;
	end;
end;

begin
	preventirq();
	disableciainterrupts();
	setmemoryconfig(1,0,0);
		
	SCREEN_BG_COL:=BLACK;
	SCREEN_FG_COL:=BLACK;
	multicolor_char_col[1]:=brown;
	multicolor_char_col[2]:=grey;
	clearscreen($FF,^$0400);
	clearscreen($FF,^$4400);
	clearscreen(BLACK,^$D800);
	
	Init();
	InitMap();
	SwitchBank();
	PaintFull();
	SwitchBank();
	PaintFull();
	InitSprites();
	InitAnimations();
	setmemoryconfig(1,@USE_KERNAL,0); // Enable all ram, turn off BASIC
	StartRasterChain(RasterTopLevel(), 0,@USE_KERNAL); // Don't use kernal
	frameStatus := 1;
	enableirq();
	enablerasterirq();
	While(true) do begin
		if(frameStatus = 0)	then begin
			inc(globaltime);	
			Update();
			Animate();
	//		PaintFull();
			frameStatus := 1;
		end;
	end;
	Loop(); 
end.



