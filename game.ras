program game;

@startblock $0f00 "Variables"

var	
	//@define DEBUG 1
	@define OVERFLOW_CHECK 1
	@define USE_KERNAL 0
	
	// Charsets
	@define charsetLoc1 $3800
	@define charsetLoc2 $7800
	@define tilesetLoc1 $3000
	@define tilesetLoc2 $7000
	@define spriteLoc1  $2000
	@define spriteLoc2  $4000
	@define tilesetCol $6c00
	// Automatically export charsets 
	@export "charsets/charset.flf" "charsets/charset.bin" 60	
 	@export "charsets/tileset.flf" "charsets/tileset.bin" 256	
	@export "sprites/sprites.flf" "sprites/sprites.bin" 40	
  	charset1: incbin("charsets/charset.bin", @charsetLoc1);
  	charset2: incbin("charsets/charset.bin", @charsetLoc2);
  	tileset1: incbin("charsets/tileset.bin", @tilesetLoc1);
   	tileset2: incbin("charsets/tileset.bin", @tilesetLoc2);
  	sprite1: incbin("sprites/sprites.bin", @spriteLoc1);
  	sprite2: incbin("sprites/sprites.bin", @spriteLoc2);
	tilesetColors :  incbin("charsets/tileset_color.bin", @tilesetCol);
	
	// Double Buffer
	currentBank: byte=0;
	time: byte=0;
	globaltime: byte=0;
	frameStatus: byte;
	screen: byte;
	debugx: byte;
	countSprite: byte=0;
	// Game	
	@define SCENES_SIZE 1
	@define DIMX 20
	@define DIMY 12
	@define DIMZ 4
	@define MAX_OBJECTS 128
	@define DIMTILES 240
	@define Z_BACK2 3
	@define Z_BACK1 2
	@define Z_MAIN 1
	@define Z_FRONT 0
	@define UNKNOWN $FF
	@define DOWN 7
	@define UP 1
	@define LEFT 3
	@define RIGHT 5
	@define SHIFT_DOWN 4
	@define SHIFT_UP 5
	@define SHIFT_LEFT 6
	@define SHIFT_RIGHT 7
	@define DOWN_LEFT 6
	@define DOWN_RIGHT 8
	@define UP_LEFT 0
	@define UP_RIGHT 2
	@define STOP 12
	@define AREA_OUT $FF
	@define AREA_DOWN 0
	@define AREA_UP 1
	@define AREA_LEFT 2
	@define AREA_RIGHT 3
	@define AREA_CENTER 4
	
	@define ANIM_MODE_FIX 0
	@define ANIM_MODE_LR 1
	@define ANIM_MODE_LR_REPEAT 2
	
	@define ANIM_WALK_L 0
	@define ANIM_WALK_R 1
	@define ANIM_STAND 2
	@define ANIM_SWIM_L 3
	@define ANIM_SWIM_R 4
	@define ANIM_CLIMB 5
	@define ANIM_ROBE 6
	
	collAreaUp: array[9] of byte = (8,7,6,5,4,3,2,1,0);
	collAreaLeft: array[9] of byte = (2,5,8,1,4,7,0,3,6);
	collAreaRight: array[9] of byte = (6,3,0,7,4,1,8,5,2);

	shiftAreaDownX: array[9] of byte = (-1, 0, 1 , -1, 0, 1, -1, 0, 1);
	shiftAreaUpX: array[9] of byte = (1, 0, -1, 1, 0, -1, 1, 0, -1);
	shiftAreaLeftX: array[9] of byte = (1, 1, 1, 0, 0, 0, -1, -1, -1);
	shiftAreaRightX: array[9] of byte = (-1, -1, -1,0, 0, 0, 1, 1, 1);

	shiftAreaDownY: array[9] of byte = (-1, -1, -1, 0, 0, 0, 1, 1, 1);
	shiftAreaUpY: array[9] of byte = ( 1, 1, 1 , 0, 0, 0, -1, -1, -1);
	shiftAreaLeftY: array[9] of byte = ( -1, 0, 1, -1, 0, 1, -1, 0, 1);
	shiftAreaRightY: array[9] of byte = ( 1, 0, -1,  1, 0, -1, 1, 0, -1);
	
	tempPointer: pointer of byte;
	
	@define ID_TEXTBOX 128
	@define ID_IMAGEBOX 129
	@define ID_MENU 130
	@define STATE_PLAY 0
	@define STATE_DO_NOTHING 1
	@define STATE_PAUSE_TAGS 2
	@define STATE_PAUSE_ALL 3
	
	@define DURATION_KILL 50
	
	@define SCRIPT_INIT 0
	@define SCRIPT_PLAY 1
	
	@define COMP_PHYSICS_0         %00000001
	@define COMP_COLLIDE_ABLE_0    %00000010
	@define COMP_SHIFT_PLATTFORM_0 %00000100	
	@define COMP_DESTROY_COLLIDE_0 %00001000
 	@define COMP_ERASE_ABLE_0      %00010000
 	@define COMP_WATER_0           %00100000
	@define COMP_ANIMATION_0		  %01000000	
	@define COMP_CONTROL_0		  %10000000
    @define COMP_PUSHPULL_1 		  %00000001
 	// https://www.aivosto.com/articles/petscii.pdf
 	@define LEV_CHARACTER $40
	@define LEV_BRICK $61
	@define LEV_STONE $6f
	@define LEV_SAND $73
	@define LEV_WATER $3d
	@define LEV_SHIFT_UP $5E
	@define LEV_SHIFT_DOWN $59
	@define LEV_SHIFT_LEFT $3C
	@define LEV_SHIFT_RIGHT $3E
	
	@define CTRL_STATE_WALK 0
	@define CTRL_STATE_CLIMB 1
	@define CTRL_STATE_ROBE 2
	@define CTRL_STATE_SWIM 3
	
//	lev0: string = ("^>aa<ao  ao ao ao aaa   a aa  a  aa o  aao    aaa  aa o  @ aaa a  o o o o  ^ ^Yaao        ^    o ^Yaa      ^   oo o  ^Yaa     ^  o o o o ^Yaa    o o o o o     aa  o o o o o       aa                  aa                  aa                  aa");
	lev0: string = ("^>aa<a   a  a  a  aaa   a aa  a  aa    aa     aaa  aa      aaa a           ^ ^Yaa         ^      ^Yaa      ^         ^Yaa     ^          ^Yaa                  aa                  aa         o        aa   ====ss@ss      aaaa    aaaaaaaaaaa aa");
	countObjects: byte;
	deletedObjects: Array[@MAX_OBJECTS] of byte;
	countDeletedObjects: byte;
	dynObjectList : Array[@MAX_OBJECTS] of byte;
	animObjectList : Array[@MAX_OBJECTS] of byte;
	countDyn: byte = 0;
	countAnim: byte = 0;
	mapback2 : Array[@DIMTILES] of byte;
	mapback1 : Array[@DIMTILES] of byte;
	mapmain : Array[@DIMTILES] of byte;
	mapfront : Array[@DIMTILES] of byte;
	state, oldState: byte;
	killDuration, killTimer: byte;
	newSceneAfterKill: boolean;
//	x1,y1: byte;
	pa: pointer of byte;

	animObject = class
		animSeq: array[4] of byte;
		considerGravity: boolean;
		size: byte;
		speed: byte;
		mode: byte;
	end;
	animList : Array[2] of animObject;


	@ifdef DEBUG
		testarea: array[9] of byte = ($00,$10,$20,$30,$40,$50,$60,$70,$80);
		ret: byte;
		iret: integer;
		i,j,c: byte;
		pg: pointer of gobject;
		pa: pointer of byte;
		x0: byte;
//		tempColArea: array[9] of byte = ( $ff, $ff, $ff,  $ff, $ff, $ff, $ff, $ff, $ff );
	@endif

@endblock

@startblock $5000 "Objects"
	gobject = class
		id: byte;
		isActive : boolean;
		components: array[4] of byte;
		
		// TransformTile
		transIsStatic: boolean;
		transX, transY, transZ, transPriority, transRot: byte;
	
		// Render
		rendToMove, rendDrawEnergy, rendInAnimCycle : boolean;
//		rendLastXpos, rendLastYpos, rendLastPathElem, rendMoveoffsetx, rendMoveoffsety, rendCenterX, rendCentery: byte;
		rendEnergyX, rendEnergyY, rendEnergyPercent, rendTilePos: byte;
		rendAsSprite: boolean;
		rendSpriteNum: byte;
		
		// Physics
		physGravity: byte;
		physRollLeftRight, physHighFall: boolean;

		// ShiftPlattform
		shiftDir: byte;
		
		// Control
		controlJump: boolean;
		controlState: byte;
		controlLastPortal: byte;
		controlPermanentSwim: boolean;
		controlFollowKeyRight, controlFollowKeyLeft: byte;
		controlPressLeft, controlPressRight, controlPressUp, controlPressDown: boolean;
		
		// DestroyCollide
		destColIgnoreTag: byte;
		destColDamageEnergy: byte;
		destColKey: byte;
		
		// Water
		waterFloaterDir: byte;
		
		// Activate
		actPermanentSwim: boolean;
		actLastPortal: byte;
		
		// Animation
		animId: byte;
		animPos: byte;
		animFinish: boolean;
		
		// PushPull
		ppMaxEnergy, ppEnergy: byte;
	end;
	objectList : Array[@MAX_OBJECTS] of gobject;
@endblock

@startblock $7a00 "Code"

procedure Init();
begin
	state := @STATE_PLAY;
	oldState := 255;
	killDuration := 0;
	killTimer := 0;
	newSceneAfterKill := true;
	countObjects := 0;
	countDeletedObjects := 0;
end;

procedure print2x2block(x,y,c: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x = $FF or y = $FF) then SCREEN_BG_COL:=BROWN;
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	moveto(x*2,y*2,screen);
	screenmemory[0]:=c;
	screenmemory[1]:=c+1;
	screenmemory[40]:=c+40;
	screenmemory[41]:=c+41;

	moveto(x*2,y*2,hi(SCREEN_COL_LOC));
	screenmemory[0]:=tilesetColors[c]+8;
	screenmemory[1]:=tilesetColors[c+1]+8;
	screenmemory[40]:=tilesetColors[c+40]+8;;
	screenmemory[41]:=tilesetColors[c+41]+8;;
end;

procedure PrintText(x: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= 40) then SCREEN_BG_COL:=BLUE;
	@ENDIF
	
	moveto(0,24,screen);
	fillfast(screenmemory,$20,40);
	screenmemory[0]:=$1c;
	screenmemory[39]:=$1d;
	moveto(x,24,screen);
	printstring("HELLO",0,40);		
end;

procedure PrintSprite(x: byte, y: byte, spriteLoc: byte, num: byte);
var
	xs: integer;
	ys: byte;
	ns: byte;
begin
	xs := 24 + (x shl 4);
	ys := 50 + (y shl 4);
	if(currentBank = 0) then begin
		ns := spriteLoc + $80;
		SetSpriteLoc(num, ns, 0);
	end
	else begin
		ns := spriteLoc;
		SetSpriteLoc(num, ns, 1);
	end;
	SpritePos(xs,ys,num);
end;

procedure PrintSpriteEmpty(i: byte, num: byte);
var
	ns: byte;
begin
	if(currentBank = 0) then begin
		ns := num + $80;
		SetSpriteLoc(i, ns, 0);
	end
	else begin
		ns := num;
		SetSpriteLoc(i, ns, 1);
	end;
	SpritePos(0,0,i);
end;


procedure print2x2blockEmpty(x,y:byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= @DIMX or y >= @DIMY) then SCREEN_BG_COL:=GREY;
	@ENDIF
	moveto(x*2,y*2,screen);
	screenmemory[0]:=255;
	screenmemory[1]:=255;
	screenmemory[40]:=255;
	screenmemory[41]:=255;
end;

procedure GetZLayerPointer(z: byte);
begin
	case z of
		@Z_BACK2: tempPointer := #mapback2;
		@Z_BACK1: tempPointer := #mapback1;
		@Z_MAIN: tempPointer := #mapmain;
		@Z_FRONT: tempPointer := #mapfront;
	end;
end;

procedure PaintPos(pos: byte);
var
	x,y: byte;
	t: byte;
	animId: byte;
	hideSprite: boolean;
	pg: pointer of gobject;
	pa: pointer of animObject;
	currentTile: byte;
	gravity: byte;
	shiftAnim: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=BROWN;
	@ENDIF
	
	x := mod(pos,@DIMX);
	y := pos / @DIMX;
	t := $FF;
	currentTile := $FF;
	hideSprite:= false;

 	if(mapfront[pos] <> 255) then begin
	 	t := mapfront[pos];
	 	hideSprite := true;
 	end
 	else if(mapmain[pos] <> 255) then begin
	 	t := mapmain[pos];
 	end
 	else if(mapback1[pos] <> 255) then begin
	 	t := mapback1[pos];
 	end
	else if(mapback2[pos] <> 255) then begin
	 	t := mapback2[pos];
 	end;
	
 	if(t <> 255) then begin
	 	pg := #objectList[t];
		pa := #animList[pg.animId];
	 	if((pg.components[0] & @COMP_ANIMATION_0) = @COMP_ANIMATION_0) then begin
			if(pg.animFinish = true) then begin
				currentTile := pa.animSeq[pg.animPos];
				moveto(16,24,screen);
				printnumber(pg.animPos);
			end
			else begin
				moveto(2,24,screen);
				printnumber(pg.animPos);
//				if(pg.animPos >= 0) then begin
					shiftAnim := 0;
					if(pa.considerGravity = true) then begin
						gravity := @DOWN;
						if((pg.components[0] & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := pg.physGravity;
						if(gravity = @UP) then shiftAnim := 1
						else if(gravity = @LEFT) then shiftAnim := 2
						else if(gravity = @RIGHT) then shiftAnim := 3;
					end;
					currentTile := pa.animSeq[pg.animPos];
					currentTile := currentTile + shiftAnim;
					moveto(4,24,screen);
					printnumber(currentTile);
										moveto(6,24,screen);
					printnumber(pa.size);

					if(pa.mode = @ANIM_MODE_FIX) then pg.animPos := 0
					else if(pa.mode = @ANIM_MODE_LR) then begin
						if(pg.animPos = pa.size - 1) then begin
							pg.animPos := 0;
							pg.animFinish := true;
						end
						else inc(pg.animPos);
					end
					else if(pa.mode = @ANIM_MODE_LR_REPEAT) then begin
						if(pg.animPos = pa.size - 1) then begin
							pg.animPos := 0;
							pg.animFinish := false;
						end
						else inc(pg.animPos);
					end;
//				end
//				else currentTile := pa.animSeq[pg.animPos];
			
			end;
		end
		else currentTile := pg.rendTilePos;
		
	 	if(pg.rendAsSprite = true and hideSprite = false) then begin
		 	PrintSprite(x,y,currentTile,pg.rendSpriteNum)
		 end
	 	else
	 		print2x2block(x,y,currentTile);
	end
	else print2x2blockEmpty(x,y);
end;

function ConvertShift(gravity: byte, pos: byte) : integer;
var 
    pg: pointer of gobject;
    ret: integer;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= 9) then SCREEN_BG_COL:=RED;
	@ENDIF
	if(gravity = @DOWN) then ret := CreateInteger(shiftAreaDownX[pos],shiftAreaDownY[pos])
 	else if(gravity = @UP) then ret := CreateInteger(shiftAreaUpX[pos],shiftAreaUpY[pos])
 	else if(gravity = @LEFT) then ret := CreateInteger(shiftAreaLeftX[pos],shiftAreaLeftY[pos])
 	else if(gravity = @RIGHT) then ret := CreateInteger(shiftAreaRightX[pos],shiftAreaRightY[pos]);
    ConvertShift := ret; 	
end;


function CalcPosition(startx,starty, pos: byte) : integer;
var
	destx, desty: byte;
begin
	destx := startx + shiftAreaDownX[pos];
	desty := starty + shiftAreaDownY[pos];
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPosition := CreateInteger(destx, desty); 
end;


function CalcPositionMapPos(startx,starty, pos: byte) : byte;
var 
	npos: integer;
begin
	npos := CalcPosition(startx,starty, pos);
	CalcPositionMapPos := hi(npos) + lo(npos) * @DIMX;
end;


function GetObjArea(id: byte, z: byte, pos:byte, comp: byte, compIdx: byte) : byte;
var
	pg, pgCol: pointer of gobject;
	gravity: byte;
	mapPos, colId, ret, val, gpos: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(id >= @MAX_OBJECTS) then SCREEN_BG_COL:=LIGHT_GREY;
	@ENDIF
	pg := #objectList[id];
	gravity := @DOWN;
	if((pg.components[0] & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := pg.physGravity;
	if(pg.physGravity = @DOWN) then gpos := pos
	else if(pg.physGravity = @UP) then gpos := collAreaUp[pos] 
	else if(pg.physGravity = @LEFT) then gpos := collAreaLeft[pos] 
	else if(pg.physGravity = @RIGHT) then gpos := collAreaRight[pos];

	GetZLayerPointer(z);

	mapPos := CalcPositionMapPos(pg.transX, pg.transY, gpos);
	colId := tempPointer[mapPos];
	ret := $FF;
	if(colId <> $FF) then begin
		pgCol := #objectList[colId];
		val := pgCol.components[compIdx] & comp;
		if(val = comp) then ret := colId;
	end;

	GetObjArea := ret;

end;

function CalcPositionX(startx,offsetx: byte) : byte;
var
	destx: byte;
begin
	destx := startx + offsetx;
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	CalcPositionX := destx;
end;

function CalcPositionY(starty,offsety: byte) : byte;
var
	desty: byte;
begin
	desty := starty + offsety;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPositionY := desty;
end;

procedure ChangeMapItem(id: byte, oldx: byte, oldy: byte, x: byte, y: byte, z:byte);
var
	oldpos: byte;
	pos: byte;
	pg: pointer of gobject;
begin
	oldpos := oldx + oldy * @DIMX;
	pos := x + y * @DIMX;
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
		if(oldpos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	tempPointer[oldpos] := $FF;
	tempPointer[pos] := id;
	PaintPos(oldpos);
	PaintPos(pos);
end;

procedure SetPos(i: byte,oldx:byte, oldy:byte, x: byte, y: byte, z: byte);
var
	pg: pointer of gobject;
	pos: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(i >= @MAX_OBJECTS) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	pg := #objectList[i];
	pos := x + y * @DIMX;
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	GetZLayerPointer(z);

//	if(tempPointer[pos] = $FF) then begin
		ChangeMapItem(i, oldx, oldy, x, y, z);
		pg.transX := x;
		pg.transY := y;
//	end;
end;

procedure AddMapItem(Id: byte, x: byte, y: byte, z:byte);
var
	pos: byte;
	pm : pointer of byte;
begin
	pos := x + y * @DIMX;
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	tempPointer[pos] := Id;
end;

procedure ClearMap();
var 
	m: byte;
	pm : pointer of byte;
begin
    for m := 0 to @DIMTILES do	
	begin
 	 	mapback2[m] := 255;
 	 	mapback1[m] := 255;
 	 	mapmain[m] := 255;
 	 	mapfront[m] := 255;
 	end;
end;

procedure AddDynItem(i: byte);
begin
	dynObjectList[countDyn] := i;
	inc(countDyn);
end;

procedure AddAnimItem(i: byte);
begin
	animObjectList[countAnim] := i;
	inc(countAnim);
end;


function PopDeletedIndex() : byte;
var
	i: byte;
	ret: byte;
	moveFrom: byte;
begin
	
	if(countDeletedObjects > 0) then begin 
		ret := deletedObjects[0];
		for i:=1 to countDeletedObjects do begin
			moveFrom := deletedObjects[i];
			deletedObjects[i-1] := moveFrom;
		end;
		dec(countDeletedObjects);
	end
	else ret := $FF;
	
	PopDeletedIndex := ret;
end;

procedure AddDeletedIndex(id: byte);
begin
	deletedObjects[countDeletedObjects] := id;
	inc(countDeletedObjects);
end;

function GetIndex() : byte;
var
	ret: byte;
begin
	ret := PopDeletedIndex();
	if(ret = $FF) then begin
		inc(countObjects);
		ret := countObjects;
	end;
	GetIndex := ret;
end;


procedure PaintFull();
var
	i: byte;
begin
    for i := 0 to @DIMTILES do
	begin
		PaintPos(i);
	end;
end;

procedure DeleteMapItem(id: byte, x: byte, y: byte, z:byte);
var	
	pos: byte;
begin
	pos := x + y * @DIMX;
	GetZLayerPointer(z); 

	tempPointer[pos] := 255;
end;
	
	
procedure DeletePos(id: byte);
var
	pg: pointer of gobject;
begin
	pg := #objectList[id];

	DeleteMapItem(id, pg.transX, pg.transY, pg.transZ);
	AddDeletedIndex(id);
end;

procedure SwitchBank();
begin
	if (currentBank = 0) then 
	begin
		SetBank(VIC_BANK1);
		setcharsetlocation(@tilesetLoc2);
		screen := hi(screen_char_loc);
		currentBank := 1;
	end
	else 
	begin
		SetBank(VIC_BANK0);
		setcharsetlocation(@tilesetLoc1);
		screen := hi(screen_char_loc2);
		currentBank := 0;
	end;

end;



procedure DamageCollide(id: byte);
begin
	// TODO
end;


@include "ControlComponent.ras"
@include "PhysComponent.ras"

procedure UpdateObject(id: byte);
var
	pg: pointer of gobject;
begin
	pg := #objectList[id];
	if(pg.components[0] & @COMP_PHYSICS_0 = @COMP_PHYSICS_0) then UpdatePhysics(id);
	if(pg.components[0] & @COMP_CONTROL_0 = @COMP_CONTROL_0) then begin 
		InputControl(id); 
		UpdateControl(id);
	end;
end;


procedure Update();
var 
	i: byte;
	id: byte;
begin
	ReadJoy2();

	if(countDyn <> 0) then begin
		for i:=0 to countDyn do	begin
			id := dynObjectList[i];
			UpdateObject(id);
		end;
	end;
end;


interrupt RasterBottomText();

interrupt RasterTopLevel();
begin
	startirq(@USE_KERNAL);
	//poke(^$d418,0,31);
	setmulticolormode();
	setcharsetlocation(@tilesetLoc1);
	SCREEN_FG_COL:=BLACK;
	if(frameStatus = 1) then begin
		if(time = 0) then begin
			SwitchBank();
		end
		else if(time = 1 and currentBank = 0) then copyFullScreen(^$0400, ^$4400)
		else if(time = 1 and currentBank = 1) then copyFullScreen(^$4400, ^$0400)
	end;
	if(time = 2) then begin
      	frameStatus := 0;
    end;
    if(time < 4) then inc(time)
	else if(frameStatus = 1) then time:=0;
	RasterIRQ(RasterBottomText(), 242, @USE_KERNAL);
	closeIrq();
end;

interrupt RasterBottomText();
begin
	startirq(@USE_KERNAL);
	setregularcolormode();
	setcharsetlocation(@charsetLoc1);
	SCREEN_FG_COL:=WHITE;

	if(time = 2) then begin
		PrintText(4);
	end;
		
	RasterIRQ(RasterTopLevel(),20,@USE_KERNAL);
	closeIrq();
//	setcharsetandscreenlocation(@tilesetLoc1,$4400);
end;

@include "GObjects.ras"

procedure InitAnimations();
var
	pa: pointer of animObject;

begin
	pa := #animList[@ANIM_WALK_L];
	pa.animSeq[0] := $00;
	pa.animSeq[1] := $04;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := true;
	pa.size := 2;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_LR_REPEAT;
end;

procedure InitSprites();
var
	i:byte;
begin
	// Set all sprites to be multicolor
	sprite_multicolor:=$ff;
	// Set common sprite multicolor #1 
	sprite_multicolor_reg1:=dark_grey;
	// Set  common sprite multicolor #2 
	sprite_multicolor_reg2:=white;
	for i := 0 to 8 do begin 
		sprite_color[i]:=light_red;
		SpritePos(0,0,i);
	end;
	// Turn on sprite 0 (or @useSprite)
	sprite_bitmask := $FF;
//	togglebit(sprite_bitmask,0,1);
end;
@endblock

procedure InitMap();
var 
	i,x,y,c : byte;
begin
	ClearMap();
	countDyn := 0;
	countAnim := 0;	
	
	for i := 0 to @DIMTILES do
	begin
		c := lev0[i];
		x := mod(i,@DIMX);
		y := i / @DIMX;
		case c of
			@LEV_CHARACTER: InitCharacter(x,y);
			@LEV_BRICK: InitBrick(x, y);
			@LEV_STONE: InitStone(x, y);
			@LEV_WATER: InitWater(x, y);
			@LEV_SAND: InitSand(x, y);
			@LEV_SHIFT_UP: InitShiftPlattformUp(x, y);
			@LEV_SHIFT_DOWN: InitShiftPlattformDown(x, y);
			@LEV_SHIFT_RIGHT: InitShiftPlattformRight(x, y);
			@LEV_SHIFT_LEFT: InitShiftPlattformLeft(x, y);
		end;
	end;
end;

begin
	preventirq();
	disableciainterrupts();
	setmemoryconfig(1,0,0);
		
	@IFDEF DEBUG
		clearscreen($20,^$0400);
		InitMap();
		moveto(0,0,$04);
		pg := #objectList[21];
		pg.physGravity := @DOWN;

		moveto(0,10,$04);
		printnumber(lev0[0]);
		GetCollisionArea(#tempColArea, $1C, @Z_MAIN, 0, @COMP_COLLIDE_ABLE_0,0);
		pa := #tempColArea;
		c := 0;
		for i := 0 to 3 do begin
			for j := 0 to 3 do begin
				moveto(j*2,i*2,$04);
				x0 := pa[c];
				printnumber(x0);
				c := c + 1;
			end;
		end;		
		ret := GetObjArea($1C, #tempColArea, 7);		
		moveto(0,10,$04);
		printnumber(ret);
		Loop(); 
		
		
//		ret := (objectList[21].components[0] & @COMP_PHYSICS_0);
//		if(ret = @COMP_PHYSICS_0) then ret:=$FF;
		//ret := HasPhysicsComponent(21);
		//ret := GetObjArea(21, #testarea, 2);
		//iret := CalcPosition(1,12,1,1);
//		UpdatePhysics(21);
//		UpdatePhysics(21);
		SetPos(21,1,1,@Z_MAIN);
		GetCollisionArea(#tempColArea, 21, @Z_MAIN, 0, @COMP_COLLIDE_ABLE_0,0);
//		SetPos(21,1,2,@Z_MAIN);
//		GetCollisionArea(#tempColArea, 21, @Z_MAIN, 0, @COMP_COLLIDE_ABLE_0,10);
		ret := GetObjArea(21, #tempColArea, 8);

		pa := #tempColArea;
		c := 0;
		for i := 0 to 3 do begin
			for j := 0 to 3 do begin
				moveto(j*2,i*2,$04);
				x0 := pa[c];
				printnumber(x0);
				c := c + 1;
			end;
		end;		
		SetPos(21,1,2,@Z_MAIN);
		GetCollisionArea(#tempColArea, 21, @Z_MAIN, 0, @COMP_COLLIDE_ABLE_0,10);
		ret := GetObjArea(21, #tempColArea, 8);

		pa := #tempColArea;
		c := 0;
		for i := 0 to 3 do begin
			for j := 0 to 3 do begin
				moveto(j*2,10+i*2,$04);
				x0 := pa[c];
				printnumber(x0);
				c := c + 1;
			end;
		end;		

/*		moveto(0,10,$04);
		printnumber(ret); 
		printnumber(hi(iret));
		moveto(0,10,$04);
		printnumber(lo(iret)); */
		Loop();
	@ENDIF
	SCREEN_BG_COL:=BLACK;
	SCREEN_FG_COL:=BLACK;
	multicolor_char_col[1]:=brown;
	multicolor_char_col[2]:=grey;
	clearscreen($FF,^$0400);
	clearscreen($FF,^$4400);
	clearscreen(BLACK,^$D800);
	
	Init();
	InitMap();
	SwitchBank();
	PaintFull();
	SwitchBank();
	PaintFull();
	InitSprites();
	InitAnimations();
	setmemoryconfig(1,@USE_KERNAL,0); // Enable all ram, turn off BASIC
	StartRasterChain(RasterTopLevel(), 0,@USE_KERNAL); // Don't use kernal
	frameStatus := 1;
	enableirq();
	enablerasterirq();
	While(true) do begin
		if(frameStatus = 0)	then begin
			inc(globaltime);	
			Update();
	//		PaintFull();
			frameStatus := 1;
		end;
	end;
	Loop(); 
end.


