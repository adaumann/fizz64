program game;

@startblock $1200 "Variables"

var	
	//@define DEBUG 1
	@define OVERFLOW_CHECK 1
	@define USE_KERNAL 0

	// Charsets
	@define charsetLoc1 $3800
	@define charsetLoc2 $7800
	@define tilesetLoc1 $3000
	@define tilesetLoc2 $7000
	@define spriteLoc1  $2000
	@define spriteLoc2  $4800
	@define tilesetCol  $3a00
	// Automatically export charsets 
	@export "charsets/charset.flf" "charsets/charset.bin" 60	
 	@export "charsets/tileset.flf" "charsets/tileset.bin" 256	
	@export "sprites/spr.flf" "sprites/spr.bin" 4096	
  	charset1: incbin("charsets/charset.bin", @charsetLoc1);
  	charset2: incbin("charsets/charset.bin", @charsetLoc2);
  	tileset1: incbin("charsets/tileset.bin", @tilesetLoc1);
   	tileset2: incbin("charsets/tileset.bin", @tilesetLoc2);
  	sprite1: incbin("sprites/spr.bin", @spriteLoc1);
  	sprite2: incbin("sprites/spr.bin", @spriteLoc2);
	tilesetColors :  incbin("charsets/tileset_color.bin", @tilesetCol);
	
	// Double Buffer
	currentBank: byte=0;
	time: byte=0;
	globaltime: byte=0;
	frameStatus: byte;
	screen: byte;
	debugx: byte;
	countSprite: byte=0;
	
	// Game	
	@define SCENES_SIZE 1
	@define DIMX 20
	@define DIMY 12
	@define DIMZ 4
	@define MAX_OBJECTS 240
	@define MAX_CONTROLS 2
	@define MAX_LASER 30
	@define MAX_ACTORS 16
	@define MAX_LEV_STRINGS 8
	@define ACTOR_LENGTH 8

	@define DIMTILES 240
	@define DIMANIMS 14
	@define Z_BACK2 3
	@define Z_BACK1 2
	@define Z_MAIN 1
	@define Z_FRONT 0
	@define UNKNOWN $FF
	@define DOWN 7
	@define UP 1
	@define LEFT 3
	@define RIGHT 5
	@define SHIFT_DOWN 4
	@define SHIFT_UP 5
	@define SHIFT_LEFT 6
	@define SHIFT_RIGHT 7
	@define DOWN_LEFT 6
	@define DOWN_RIGHT 8
	@define UP_LEFT 0
	@define UP_RIGHT 2
	@define STOP 12
	@define AREA_OUT $FF
	@define AREA_DOWN 0
	@define AREA_UP 1
	@define AREA_LEFT 2
	@define AREA_RIGHT 3
	@define AREA_CENTER 4
	@define LASER_STEP 4
	@define TURN_RIGHT 1
	@define TURN_LEFT 2
	@define TURN_THROUGH  3
	@define ON 1
	@define OFF $FF
	@define LASER_TYPE_USER 10 
	@define REND_TYPE_TILE 0
	@define REND_TYPE_SPRITE 1
	@define REND_TYPE_BYTE 2
	
	@define ANIM_MODE_FIX 0
	@define ANIM_MODE_LR 1
	@define ANIM_MODE_LR_REPEAT 2
	@define ANIM_MODE_MANUAL 3
	
	@define ANIM_WALK_L 0
	@define ANIM_WALK_R 1
	@define ANIM_STAND 2
	@define ANIM_SWIM_L 3
	@define ANIM_SWIM_R 4
	@define ANIM_CLIMB 5
	@define ANIM_ROBE 6
	@define ANIM_PORTAL 7
	@define ANIM_SWITCH_ON 8
	@define ANIM_SWITCH_OFF 9
	@define ANIM_DOOR_ON 10
	@define ANIM_DOOR_OFF 11
	@define ANIM_EXIT_ON 12
	@define ANIM_EXIT_OFF 13
	
	collAreaUp: array[9] of byte = (8,7,6,5,4,3,2,1,0);
	collAreaLeft: array[9] of byte = (2,5,8,1,4,7,0,3,6);
	collAreaRight: array[9] of byte = (6,3,0,7,4,1,8,5,2);

	shiftAreaDownX: array[9] of byte = (-1, 0, 1 , -1, 0, 1, -1, 0, 1);
	shiftAreaUpX: array[9] of byte = (1, 0, -1, 1, 0, -1, 1, 0, -1);
	shiftAreaLeftX: array[9] of byte = (1, 1, 1, 0, 0, 0, -1, -1, -1);
	shiftAreaRightX: array[9] of byte = (-1, -1, -1,0, 0, 0, 1, 1, 1);

	shiftAreaDownY: array[9] of byte = (-1, -1, -1, 0, 0, 0, 1, 1, 1);
	shiftAreaUpY: array[9] of byte = ( 1, 1, 1 , 0, 0, 0, -1, -1, -1);
	shiftAreaLeftY: array[9] of byte = ( -1, 0, 1, -1, 0, 1, -1, 0, 1);
	shiftAreaRightY: array[9] of byte = ( 1, 0, -1,  1, 0, -1, 1, 0, -1);
	
	tempPointer: pointer of byte;
	
	@define ID_TEXTBOX 128
	@define ID_IMAGEBOX 129
	@define ID_MENU 130
	@define STATE_PLAY 0
	@define STATE_DO_NOTHING 1
	@define STATE_PAUSE_TAGS 2
	@define STATE_PAUSE_ALL 3
	
	@define DURATION_KILL 50
	
	@define SCRIPT_INIT 0
	@define SCRIPT_PLAY 1
	
	@define COMP_PHYSICS_0          %00000001
	@define COMP_COLLIDE_ABLE_0     %00000010
	@define COMP_SHIFT_PLATTFORM_0  %00000100	
	@define COMP_DESTROY_COLLIDE_0  %00001000
 	@define COMP_ERASE_ABLE_0       %00010000
 	@define COMP_WATER_0            %00100000
	@define COMP_ANIMATION_0	    %01000000	
	@define COMP_CONTROL_0		    %10000000
    @define COMP_PUSHPULL_1 	    %00000001
    @define COMP_CLIMB_ABLE_1 	    %00000010
    @define COMP_ROBE_ABLE_1 	    %00000100
    @define COMP_FLOATER_1 		    %00001000
	@define COMP_PORTAL_1 		    %00010000
	@define COMP_GRAVPAD_1		    %00100000
	@define COMP_LASER_1		   	%01000000
	@define COMP_MIRROR_1		    %10000000
	@define COMP_DESTROY_ABLE_2     %00000001
	@define COMP_LASERBEAN_2		   %00000010
	@define COMP_LASERTRANS_ABLE_2  %00000100
	@define COMP_LASERONCE_2        %00001000
	@define COMP_PORTAL_ACTIVATE_2  %00010000
	@define COMP_FONTAINE_2         %00100000
	@define COMP_SWITCH_2           %01000000
	@define COMP_DOOR_2             %10000000
	@define COMP_EXIT_3             %00000001
	@define COMP_WAYPOINT_3         %00000010
 	// https://www.aivosto.com/articles/petscii.pdf
 	@define LEV_CHARACTER $40
	@define LEV_BRICK $61
	@define LEV_STONE $62
	@define LEV_SAND $73
	@define LEV_WATER $3d
	@define LEV_WATER_UP $27
	@define LEV_WATER_DOWN $26
	@define LEV_WATER_LEFT $7b
	@define LEV_WATER_RIGHT $7d
	@define LEV_SHIFT_DOWN $59
	@define LEV_SHIFT_UP $5E
	@define LEV_SHIFT_LEFT $3C
	@define LEV_SHIFT_RIGHT $3E
	@define LEV_LADDER $68
	@define LEV_ROBE_DOWN $5f
	@define LEV_ROBE_UP $2d
	@define LEV_ROBE_LEFT $21
	@define LEV_ROBE_RIGHT $7C
	@define LEV_LADDER $68
	@define LEV_PORTAL $6F
	@define LEV_GRAVPAD_DOWN $32
	@define LEV_GRAVPAD_UP $38
	@define LEV_GRAVPAD_LEFT $34
	@define LEV_GRAVPAD_RIGHT $36
	@define LEV_MIRROR_LEFT $6e
	@define LEV_MIRROR_RIGHT $6d
	@define LEV_GLASS $67
	@define LEV_LASER_TRANSPORT $74
	@define LEV_LASER_TRANSPORT_ONCE $75
	@define LEV_PUSH_BOX $64
	@define LEV_PULL_BOX $65
	@define LEV_PORTAL_ACTIVATE  $63
	@define LEV_FONTAINE_DOWN $5b
	@define LEV_FONTAINE_LEFT $28
	@define LEV_FONTAINE_RIGHT $29
	@define LEV_FONTAINE_UP $5d
	@define LEV_CANNON_DOWN $31
	@define LEV_CANNON_UP $39
	@define LEV_CANNON_LEFT $37
	@define LEV_CANNON_RIGHT $33
	@define LEV_SWITCH_MANUAL $72
	@define LEV_DOOR $78
	@define LEV_EXIT $58

	@define CTRL_STATE_WALK 0
	@define CTRL_STATE_CLIMB 1
	@define CTRL_STATE_ROBE 2
	@define CTRL_STATE_SWIM 3
	@define CTRL_STATE_JUMP 4

	@define EVENT_INIT_LEVEL 0
	@define EVENT_SWITCH_ON 1
	@define EVENT_SWITCH_OFF 2
	@define EVENT_WAYPOINT_ENTER 3
	@define EVENT_WAYPOINT_LEAVE 4
	
	@define ACTION_DOOR_OPEN 1
	@define ACTION_DOOR_CLOSE 2
	@define ACTION_EXIT_OPEN 3
	@define ACTION_EXIT_CLOSE 4
	@define ACTION_PRINT_TEXT 5
	@define ACTION_CLEAR_TEXT 6
	@define ACTION_LASERCANNON_ON 7
	@define ACTION_LASERCANNON_OFF 8
	@define ACTION_FONTAINE_ON 9
	@define ACTION_FONTAINE_OFF 10
	
	
//	lev0: string = ("^>aa<ao  ao ao ao aaa   a aa  a  aa o  aao    aaa  aa o  @ aaa a  o o o o  ^ ^Yaao        ^    o ^Yaa      ^   oo o  ^Yaa     ^  o o o o ^Yaa    o o o o o     aa  o o o o o       aa                  aa                  aa                 4aa");
    lev0: string = ("xX{aaaaaa  a  a  aaa  ^a aa  a  aa    aa6    aaa  aa      aaa a6   1[ 2    ^ ^Yaa     o   ^      ^Yaa&     ^         ^Yaa&    ^          ^Yaa&            h    aa& 4------====hh   aa&m   n  @b    =  4aa   x===ss rs8 h o aaaa    aaaaaaaaaaaaaa");
	lev0strings: Array[@MAX_LEV_STRINGS] of string = ("WELCOME","aa");
										  //event, action, senderpos, receiverpos, p1, p2, p3, p4
	lev0actor: Array[@MAX_ACTORS * @ACTOR_LENGTH] of byte = (1, 1 ,211 , 204, $FF, $FF, $FF, $FF,
												            2, 2 ,211 , 204, $FF, $FF, $FF, $FF,	 
												 		    1, 1, 211,  0,   $FF, $FF, $FF, $FF,
												 			2, 2, 211,  0, $FF, $FF, $FF, $FF,
												 			1, 3, 211, 1,$FF, $FF, $FF, $FF,
												 			2, 4, 211, 1,$FF, $FF, $FF, $FF,
												 			3, 5, 211, $FF, $00, 17, 10, $FF,
												 			4, 6, 211, $FF, $FF, $FF, $FF, $FF,
												 			0, 5, $FF, $FF, $00, 17, 10, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF); 	
//	lev0: string = ("    ccccccccccccc                                               @                                          t u        Yaa     ^  b b b b ^Yaa    b b b b b     aa  b b b b b   o   aa        d e o     aa   n d  gg  m  e  aaaaaaaaaaaaaaaaaaaaaa");
	@define DO_ACTIVATE_SWITCH_START 17
	txtDoActiveSwitch: string=("SWITCH");
	@define ACTIVATE_SWITCH_START 12
	txtActiveSwitch:   string=("SWITCH ACTIVATED");
	@define DEACTIVATE_SWITCH_START 11
	txtDeactiveSwitch: string=("SWITCH DEACTIVATED");
	
	countObjects: byte;
	deletedObjects: Array[@MAX_OBJECTS] of byte;
	dynObjectList : Array[@MAX_OBJECTS] of byte;
	animObjectList : Array[@MAX_OBJECTS] of byte;
	countDyn: byte = 0;
	countAnim: byte = 0;
	mapback2 : Array[@DIMTILES] of byte;
	mapback1 : Array[@DIMTILES] of byte;
	mapmain : Array[@DIMTILES] of byte;
	mapfront : Array[@DIMTILES] of byte;
	portals: Array [2] of byte;
	lastPortal: byte;
	state, oldState: byte;
	killDuration, killTimer: byte;
	newSceneAfterKill: boolean;
	pa: pointer of byte;
	textTimer: byte;

	@define ANIM_CONSIDER_GRAV_IGNORE 0
	@define ANIM_CONSIDER_GRAV_FULL 1
//	@define ANIM_CONSIDER_GRAV_HALF 2
	
	animObject = class
		animSeq: array[4] of byte;
		considerGravity: byte;
		size: byte;
		speed: byte;
		mode: byte;
	end;
	animList : Array[@DIMANIMS] of animObject;

@endblock

@startblock $e000 "Objects"
	actorObject = record
		event: byte;
		senderId: byte;
		action: byte;
		receiverId: byte;
		param0, param1, param2, param3: byte;
	end;

	controlObject = record
		controlJumpStep: byte;
		controlState: byte;
		b_controlPermanentSwim: byte;
		controlFollowKeyRight, controlFollowKeyLeft: byte;
		b_controlPressLeft, b_controlPressRight, b_controlPressUp, b_controlPressDown, b_controlPressAction: byte;
		controlLastPortal: byte;
		b_waitRelease, b_release: byte;
		waypointId: byte;
		lastWaypointId: byte;
	end;

	gobject = record
		component0, component1, component2, component3: byte;
		
		// TransformTile
		transX, transY, transZ: byte;
	
		// Render
//		rendLastXpos, rendLastYpos, rendLastPathElem, rendMoveoffsetx, rendMoveoffsety, rendCenterX, rendCentery: byte;
//		rendEnergyX, rendEnergyY, rendEnergyPercent: byte; 
		rendTilePos: byte;
		rendType: byte;
		rendSpriteNum: byte;
		
		// Physics
		physGravity: byte;
		b_physFallDown: byte;
		b_physRollLeftRight, b_physHighFall: byte;

		// ShiftPlattform
		shiftDir: byte;
		
		// Control
		controlId: byte;
		b_hasMoved: byte;
		
		// DestroyCollide
//		destColIgnoreTag: byte;
//		destColDamageEnergy: byte;
//		destColKey: byte;
		
		// Water
		waterFloaterDir: byte;
				
		// Animation
		animId: byte;
		animPos: byte;
		animFinish: byte;
		

		// Portal
		portalFireExitDir: byte;
		
		// Laser, Fontaine
		laserDir: byte;
		lastLaserDir: byte;
 		laserLastTransportAble: byte;
 		laserType : byte;
 		laserTag: byte;
		currentLaser: byte; 		
 		
		// Mirror
 		mirrorTurn: byte;
		
		// PushPull  , Door, Exit, Switch
		onOff: byte;
	end;
	objectList : Array[@MAX_OBJECTS] of gobject;
	controlList : Array[@MAX_CONTROLS] of controlObject;
	actorList : Array[@MAX_ACTORS] of actorObject;
@endblock

@startblock $5800 "Code"

procedure Init();
begin
	state := @STATE_PLAY;
	oldState := 255;
	killDuration := 0;
	killTimer := 0;
	newSceneAfterKill := true;
	countObjects := 0;
	countDyn := 0;
	countAnim := 0;
	textTimer := 0;
end;

procedure print2x2block(x,y,c: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x = $FF or y = $FF) then SCREEN_BG_COL:=BROWN;
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	moveto(x*2,y*2,screen);
	screenmemory[0]:=c;
	screenmemory[1]:=c+1;
	screenmemory[40]:=c+40;
	screenmemory[41]:=c+41;

	moveto(x*2,y*2,hi(SCREEN_COL_LOC));
	screenmemory[0]:=tilesetColors[c]+8;
	screenmemory[1]:=tilesetColors[c+1]+8;
	screenmemory[40]:=tilesetColors[c+40]+8;;
	screenmemory[41]:=tilesetColors[c+41]+8;;
end;

procedure print1x1block(x,y,c: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x = $FF or y = $FF) then SCREEN_BG_COL:=BROWN;
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	moveto(x*2,y*2,screen);
	screenmemory[0]:=c;
	screenmemory[1]:=c;
	screenmemory[40]:=c;
	screenmemory[41]:=c;

	moveto(x*2,y*2,hi(SCREEN_COL_LOC));
	screenmemory[0]:=tilesetColors[c]+8;
	screenmemory[1]:=tilesetColors[c]+8;
	screenmemory[40]:=tilesetColors[c]+8;;
	screenmemory[41]:=tilesetColors[c]+8;;
end;

procedure CycleWater();
var
	sp: pointer;
	dp: pointer;
	waterStep : byte;
begin	
	waterStep := mod(globaltime,4);
		 
	sp := @tilesetLoc1 + (240 + waterStep) * 8;
	dp := @tilesetLoc1 + 22*8;
	MemCpyFast(sp, 0, dp,8);
	dp := @tilesetLoc2 + 22*8;
	MemCpyFast(sp, 0, dp,8);
	
	sp := @tilesetLoc1 + (243 - waterStep) * 8;
	dp := @tilesetLoc1 + 23*8;
	MemCpyFast(sp, 0, dp,8);
	dp := @tilesetLoc2 + 23*8;
	MemCpyFast(sp, 0, dp,8);
	
	sp := @tilesetLoc1 + (244 + waterStep) * 8;
	dp := @tilesetLoc1 + 62*8;
	MemCpyFast(sp, 0, dp,8);
	dp := @tilesetLoc2 + 62*8;
	MemCpyFast(sp, 0, dp,8);
	
	sp := @tilesetLoc1 + (247 - waterStep) * 8;
	dp := @tilesetLoc1 + 63*8;
	MemCpyFast(sp, 0, dp,8);
	dp := @tilesetLoc2 + 63*8;
	MemCpyFast(sp, 0, dp,8);
end;

procedure PrintText(x: byte, txt: pointer);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= 40) then SCREEN_BG_COL:=BLUE;
	@ENDIF
	@IFNDEF DEBUG
		moveto(0,24,screen);
		fillfast(screenmemory,$20,40);
		screenmemory[0]:=$1c;
		screenmemory[39]:=$1d;
		moveto(x,24,screen);
		printstring(txt,0,40);
	@ENDIF		
end;

procedure ClearText();
begin
	@IFNDEF DEBUG
		moveto(0,24,screen);
		fillfast(screenmemory,$20,40);
		screenmemory[0]:=$1c;
		screenmemory[39]:=$1d;
	@ENDIF
end;


procedure PrintSprite(x: byte, y: byte, spriteLoc: byte, num: byte);
var
	xs: integer;
	ys: byte;
	ns: byte;
begin
	xs := 24 + (x shl 4);
	ys := 50 + (y shl 4);
	if(currentBank = 0) then begin
		ns := spriteLoc + $80;
		SetSpriteLoc(num, ns, 0);
	end
	else begin
		ns := spriteLoc + $20;
		SetSpriteLoc(num, ns, 1);
	end;
	SpritePos(xs,ys,num);
end;

procedure PrintSpriteEmpty(i: byte, num: byte);
var
	ns: byte;
begin
	if(currentBank = 0) then begin
		ns := num + $80;
		SetSpriteLoc(i, ns, 0);
	end
	else begin
		ns := num;
		SetSpriteLoc(i, ns, 1);
	end;
	SpritePos(0,0,i);
end;


procedure print2x2blockEmpty(x,y:byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= @DIMX or y >= @DIMY) then SCREEN_BG_COL:=GREY;
	@ENDIF
	moveto(x*2,y*2,screen);
	screenmemory[0]:=255;
	screenmemory[1]:=255;
	screenmemory[40]:=255;
	screenmemory[41]:=255;
end;

procedure GetZLayerPointer(z: byte);
begin
	case z of
		@Z_BACK2: tempPointer := #mapback2;
		@Z_BACK1: tempPointer := #mapback1;
		@Z_MAIN: tempPointer := #mapmain;
		@Z_FRONT: tempPointer := #mapfront;
	end;
end;

function PaintPosAnim(t: byte, considerAnimation: boolean) : byte;
var
	x,y: byte;
	animId: byte;
	hideSprite: boolean;
	pa: pointer of animObject;
	currentTile: byte;
	gravity: byte;
	shiftAnim: byte;
	
begin
 	animId := objectList[t].animId;
	pa := #animList[animId];
 	if(considerAnimation = true and (objectList[t].component0 & @COMP_ANIMATION_0 = @COMP_ANIMATION_0)) then begin
		if(pa.considerGravity = @ANIM_CONSIDER_GRAV_IGNORE) then shiftAnim := 0
		else if(pa.considerGravity = @ANIM_CONSIDER_GRAV_FULL) then begin
			gravity := @DOWN;
			if((objectList[t].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[t].physGravity;
			if(gravity = @UP) then shiftAnim := 1
			else if(gravity = @RIGHT) then shiftAnim := 2
			else if(gravity = @LEFT) then shiftAnim := 3;
		end;
/*			else if(pa.considerGravity = @ANIM_CONSIDER_GRAV_HALF) then begin
			gravity := @DOWN;
			if((objectList[t].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[t].physGravity;
			if(gravity = @UP) then shiftAnim := 1
			else if(gravity = @RIGHT) then shiftAnim := 0
			else if(gravity = @LEFT) then shiftAnim := 1;
		end;*/
		currentTile := pa.animSeq[objectList[t].animPos];
		currentTile := currentTile + shiftAnim;
		if(pa.mode = @ANIM_MODE_FIX) then objectList[t].animPos := 0
		else if(pa.mode = @ANIM_MODE_LR and objectList[t].animFinish = false) then begin
			if(objectList[t].animPos = pa.size - 1) then begin
				objectList[t].animPos := 0;
				objectList[t].animFinish := true;
			end
			else if(mod(globaltime, pa.speed) = 0) then inc(objectList[t].animPos);
		end
		else if(pa.mode = @ANIM_MODE_LR_REPEAT) then begin
			if(objectList[t].animPos = pa.size - 1) then begin
				objectList[t].animPos := 0;
				objectList[t].animFinish := false;
			end
			else if(mod(globaltime, pa.speed) = 0) then inc(objectList[t].animPos);
		end;				
	end
	else currentTile := objectList[t].rendTilePos;
	PaintPosAnim := currentTile;
end;

procedure PaintPos(pos: byte, considerAnimation: boolean);
var
	x,y: byte;
	t: byte;
	animId: byte;
	hideSprite: boolean;
	pa: pointer of animObject;
	currentTile: byte;
	gravity: byte;
	shiftAnim: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=BROWN;
	@ENDIF
	
	x := mod(pos,@DIMX);
	y := pos / @DIMX;
	t := $FF;
	currentTile := $FF;
	hideSprite:= false;

 	if(mapfront[pos] <> 255) then begin
	 	t := mapfront[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
	 	hideSprite := true;
 	end
 	else if(mapmain[pos] <> 255) then begin
	 	t := mapmain[pos];
	 	currentTile := PaintPosAnim(t, true);
 	end
 	else if(mapback1[pos] <> 255) then begin
	 	t := mapback1[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
 	end
	else if(mapback2[pos] <> 255) then begin
	 	t := mapback2[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
 	end;
	
	if(t <> $FF) then begin	
	 	if(objectList[t].rendType = @REND_TYPE_SPRITE and hideSprite = false) then
		 	PrintSprite(x,y,currentTile,objectList[t].rendSpriteNum)
	 	else if(objectList[t].rendType = @REND_TYPE_TILE) then 
	 		print2x2block(x,y,currentTile)
	 	else 
	 		print1x1block(x,y,currentTile);
	end
	else print2x2blockEmpty(x,y);
end;

function ConvertShift(gravity: byte, pos: byte) : integer;
var 
    ret: integer;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= 9) then SCREEN_BG_COL:=RED;
		if(gravity = $FF) then SCREEN_BG_COL:=RED;
	@ENDIF
	if(gravity = @DOWN) then ret := CreateInteger(shiftAreaDownX[pos],shiftAreaDownY[pos])
 	else if(gravity = @UP) then ret := CreateInteger(shiftAreaUpX[pos],shiftAreaUpY[pos])
 	else if(gravity = @LEFT) then ret := CreateInteger(shiftAreaLeftX[pos],shiftAreaLeftY[pos])
 	else if(gravity = @RIGHT) then ret := CreateInteger(shiftAreaRightX[pos],shiftAreaRightY[pos]);
    ConvertShift := ret; 	
end;


function CalcPosition(startx,starty, pos: byte) : integer;
var
	destx, desty: byte;
begin
	destx := startx + shiftAreaDownX[pos];
	desty := starty + shiftAreaDownY[pos];
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPosition := CreateInteger(destx, desty); 
end;


function CalcPositionMapPos(startx,starty, pos: byte) : byte;
var 
	npos: integer;
begin
	npos := CalcPosition(startx,starty, pos);
	CalcPositionMapPos := hi(npos) + lo(npos) * @DIMX;
end;

function GetObjectByPosFilterComp(x: byte, y: byte, z: byte, comp: byte, compIdx: byte) : byte;
var
	mapPos, colId, ret, val: byte;
begin
	GetZLayerPointer(z);
	ret := $FF;
	mapPos := x + y * @DIMX;
	@IFDEF OVERFLOW_CHECK
		if(mapPos >= @DIMTILES) then SCREEN_BG_COL:=LIGHT_RED;
	@ENDIF

	colId := tempPointer[mapPos];
	if(colId <> $FF) then begin
		case compIdx of
	        0: val := objectList[colId].component0 & comp;
	        1: val := objectList[colId].component1 & comp;
	        2: val := objectList[colId].component2 & comp;
	        3: val := objectList[colId].component3 & comp;
    		end;
		if(val = comp) then ret := colId;
	end;

	GetObjectByPosFilterComp := ret;
end;

function GetObjArea(id: byte, z: byte, pos:byte, comp: byte, compIdx: byte, b_norm: byte) : byte;
var
	gravity: byte;
	mapPos, colId, ret, val, gpos: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(id >= @MAX_OBJECTS) then SCREEN_BG_COL:=LIGHT_GREY;
	@ENDIF
	gravity := @DOWN;
	if(b_norm = false) then begin
		if((objectList[id].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[id].physGravity;

		if(objectList[id].physGravity = @DOWN) then gpos := pos
		else if(objectList[id].physGravity = @UP) then gpos := collAreaUp[pos] 
		else if(objectList[id].physGravity = @LEFT) then gpos := collAreaLeft[pos] 
		else if(objectList[id].physGravity = @RIGHT) then gpos := collAreaRight[pos]
	end
	else gpos := pos;

	GetZLayerPointer(z);

	mapPos := CalcPositionMapPos(objectList[id].transX, objectList[id].transY, gpos);
	colId := tempPointer[mapPos];
	ret := $FF;
	if(colId <> $FF) then begin
		case compIdx of
	        0: val := objectList[colId].component0 & comp;
	        1: val := objectList[colId].component1 & comp;
	        2: val := objectList[colId].component2 & comp;
	        3: val := objectList[colId].component3 & comp;
    		end;
		if(val = comp) then ret := colId;
	end;
	GetObjArea := ret;
end;
@endblock
@startblock $7a00 "Code1"

function CalcPositionX(startx,offsetx: byte) : byte;
var
	destx: byte;
begin
	destx := startx + offsetx;
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	CalcPositionX := destx;
end;

function CalcPositionY(starty,offsety: byte) : byte;
var
	desty: byte;
begin
	desty := starty + offsety;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPositionY := desty;
end;

procedure ChangeMapItem(id: byte, oldx: byte, oldy: byte, x: byte, y: byte, z:byte);
var
	oldpos: byte;
	pos: byte;
begin
	oldpos := oldx + oldy * @DIMX;
	pos := x + y * @DIMX;
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
		if(oldpos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	tempPointer[oldpos] := $FF;
	tempPointer[pos] := id;
	// ##
	PaintPos(oldpos, true);
	PaintPos(pos, true);
end;

procedure UpdateMapItem(id: byte, x: byte, y: byte);
var
	oldpos: byte;
	pos: byte;
begin
	pos := x + y * @DIMX;
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	PaintPos(pos, true);
end;

procedure SetPos(i: byte,oldx:byte, oldy:byte, x: byte, y: byte, z: byte);
var
	pos: byte;
	waypointId, lastWaypointId, controlId: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(i >= @MAX_OBJECTS) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	pos := x + y * @DIMX;
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	controlId := objectList[i].controlId;
	objectList[i].b_hasMoved := true; 
	
	if(controlId <> $FF) then begin
		waypointId := GetObjectByPosFilterComp(x, y, @Z_BACK1, @COMP_WAYPOINT_3, 3);
		if(waypointId = $FF) then
			waypointId := GetObjectByPosFilterComp(x, y, @Z_BACK2, @COMP_WAYPOINT_3, 3);
		lastWaypointId := GetObjectByPosFilterComp(oldx, oldy, @Z_BACK1, @COMP_WAYPOINT_3, 3);
		if(lastWaypointId = $FF) then
			lastWaypointId := GetObjectByPosFilterComp(oldx, oldy, @Z_BACK2, @COMP_WAYPOINT_3, 3);
		
		controlList[controlId].waypointId := waypointId;
		controlList[controlId].lastWaypointId := lastWaypointId;
	end;
	
	ChangeMapItem(i, oldx, oldy, x, y, z);
	objectList[i].transX := x;
	objectList[i].transY := y;
end;

procedure SetZLayer(id: byte, oldz: byte, newz: byte);
var
	pos: byte;
begin
	pos := objectList[id].transX + objectList[id].transY * @DIMX;
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	objectList[id].b_hasMoved := true; 
	GetZLayerPointer(oldz);
	tempPointer[pos] := $FF;
	GetZLayerPointer(newz);
	tempPointer[pos] := id;
	objectList[id].transZ := newz;
	PaintPos(pos, true);
end;

procedure AddMapItem(Id: byte, x: byte, y: byte, z:byte);
var
	pos: byte;
begin
	pos := x + y * @DIMX;
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	tempPointer[pos] := Id;
end;

procedure ClearMap();
var 
	m: byte;
begin
    for m := 0 to @DIMTILES do	
	begin
 	 	mapback2[m] := 255;
 	 	mapback1[m] := 255;
 	 	mapmain[m] := 255;
 	 	mapfront[m] := 255;
 	end;
	portals[0] := $FF;
	portals[1] := $FF;
end;

procedure AddDynItem(i: byte);
begin
	dynObjectList[countDyn] := i;
	inc(countDyn);
end;

procedure AddAnimItem(i: byte);
begin
	animObjectList[countAnim] := i;
	inc(countAnim);
end;

function GetId() : byte;
var
	ret: byte;
begin
    if (countObjects = @MAX_OBJECTS) then	 ret := $FF
    	else begin	
		inc(countObjects);
		ret := deletedObjects[@MAX_OBJECTS - 1 - countObjects];
	end;

	GetId := ret;
end;

procedure PaintFull();
var
	i: byte;
begin
    for i := 0 to @DIMTILES do
	begin
		PaintPos(i, false);
	end;
end;

procedure DeleteMapItem(id: byte, x: byte, y: byte, z:byte);
var	
	pos: byte;
	pm: pointer of byte;
begin
	pos := x + y * @DIMX;	
	GetZLayerPointer(z); 
	tempPointer[pos] := 255;
end;

procedure DeleteDynObject(id: byte);
var	
	i,j: byte;	
	found: boolean;
begin
	i := 0;
	found := false;
	while (i < countDyn - 1 and found = false)  do
	begin
		if(dynObjectList[i] = id) then 
			found := true
		else
			inc(i);
	end;
	if(found = true) then begin
		dec(countDyn); 
		for j:= i to countDyn - 1 do begin
			dynObjectList[j] := dynObjectList[j+1];
		end;
	end;
end;

procedure DeleteAnimObject(id: byte);
var	
	i,j: byte;	
	found: boolean;
begin
	i := 0;
	found := false;
	while (i < countAnim - 1 and found = false) do
	begin
		if(animObjectList[i] = id) then 
			found := true
		else
			inc(i);
	end;
	if(found = true) then begin
		dec(countAnim); 
		for j:= i to countAnim - 1 do begin
			animObjectList[j] := animObjectList[j+1];
		end;
	end;
end;
	
procedure DeletePos(id: byte, isDyn, isAnim: byte);
var
	x,y: byte;
begin
	if(countObjects > 0) then begin
		deletedObjects[@MAX_OBJECTS - 1 - countObjects] := id;
		dec(countObjects);
		DeleteMapItem(id, objectList[id].transX, objectList[id].transY, objectList[id].transZ);
		if(isDyn = true) then DeleteDynObject(id); 
		if(isAnim = true) then DeleteAnimObject(id);
		PaintPos(objectList[id].transX + objectList[id].transY * @DIMX, true);
	end; 
end;	

procedure SwitchBank();
begin
	if (currentBank = 0) then 
	begin
		SetBank(VIC_BANK1);
		setcharsetlocation(@tilesetLoc2);
		screen := hi(screen_char_loc);
		currentBank := 1;
	end
	else 
	begin
		SetBank(VIC_BANK0);
		setcharsetlocation(@tilesetLoc1);
		screen := hi(screen_char_loc2);
		currentBank := 0;
	end;

end;



procedure DamageCollide(id: byte);
begin
	// TODO
end;

procedure CycleAnimation(id: byte);
var
	animId: byte;
	pa: pointer of animObject;

begin
 	animId := objectList[id].animId;
	pa := #animList[animId];
	if(objectList[id].animPos = pa.size - 1) then begin
		objectList[id].animPos := 0;
		objectList[id].animFinish := false;
	end
	else if(mod(globaltime, pa.speed) = 0) then inc(objectList[id].animPos);
end;

procedure SwitchAnimation(id: byte, anim: byte); 
begin
	if(objectList[id].animId <> anim) then begin
		objectList[id].animId := anim;
		objectList[id].animPos := 0;
		objectList[id].animFinish := false;
	end;
end;

procedure ClearAllLaser();
var
	i,c: byte;
	d: byte;
begin
	for i:= 0 to @DIMTILES do begin
		
		c := mapfront[i];
		if(c <> $FF and (objectList[c].component2 & @COMP_LASERBEAN_2 = @COMP_LASERBEAN_2 and objectList[c].laserTag <> $FF)) then begin 
			DeletePos(c, false, false);
		end;
		c := mapback2[i];
		if(c <> $FF and (objectList[c].component0 & @COMP_WATER_0 = @COMP_WATER_0 and objectList[c].laserTag <> $FF)) then begin 
			DeletePos(c, false, false);
		end;
	end;
end;


@include "GObjects.ras"
@include "Actions.ras"
@include "ControlComponent.ras"
@include "PhysComponent.ras"
@include "FloaterComponent.ras"
@include "FontaineComponent.ras"
@include "LaserComponent.ras"

procedure UpdateObject(id: byte);
begin
	if(objectList[id].component1 & @COMP_LASER_1 = @COMP_LASER_1) then begin 
		UpdateLaser(id);
	end;
	if(objectList[id].component0 & @COMP_PHYSICS_0 = @COMP_PHYSICS_0) then begin
		UpdatePhysics(id);
		ProcessBackObj(id);
	end;
	if(objectList[id].component0 & @COMP_CONTROL_0 = @COMP_CONTROL_0) then begin 
		InputControl(id); 
		UpdateControl(id);
		ProcessBackObj(id);
	end;
	if(objectList[id].component1 & @COMP_FLOATER_1 = @COMP_FLOATER_1) then begin 
		UpdateFloater(id);
		ProcessBackObj(id);
	end;
	if(objectList[id].component2 & @COMP_FONTAINE_2 = @COMP_FONTAINE_2) then begin 
		UpdateFontaine(id);
	end;
	objectList[id].b_hasMoved := false;
end;

procedure Update();
var 
	i: byte;
	id: byte;
begin
	ReadJoy2();
	ClearAllLaser();

	if(countDyn <> 0) then begin
		for i:=0 to countDyn do	begin
			id := dynObjectList[i];
			UpdateObject(id);
		end;
	end;
end;

procedure Animate();
var 
	i: byte;
	id: byte;
begin
	if(countAnim <> 0) then begin
		for i:=0 to countAnim do	begin
			id := animObjectList[i];
			UpdateMapItem(id, objectList[id].transX, objectList[id].transY); 
		end;
	end;
end;

interrupt RasterBottomText();

interrupt RasterTopLevel();
begin
	startirq(@USE_KERNAL);
	setmulticolormode();
	setcharsetlocation(@tilesetLoc1);
	SCREEN_FG_COL:=BLACK;
	if(frameStatus = 1) then begin
		if(time = 0) then begin
			SwitchBank();
		end
		else if(time = 1 and currentBank = 0) then copyFullScreen(^$0400, ^$4400)
		else if(time = 1 and currentBank = 1) then copyFullScreen(^$4400, ^$0400)
	end;
	if(time = 2) then begin
      	frameStatus := 0;
    end;
    if(time < 4) then inc(time)
	else if(frameStatus = 1) then time:=0;
	RasterIRQ(RasterBottomText(), 242, @USE_KERNAL);
	closeIrq();
end;

interrupt RasterBottomText();
begin
	startirq(@USE_KERNAL);
	setregularcolormode();
	setcharsetlocation(@charsetLoc1);
	SCREEN_FG_COL:=WHITE;

	@IFDEF DEBUG
	if(time = 2) then begin
		moveto(0,24,screen);
		fillfast(screenmemory,$20,40);
	end;
	@ENDIF
		
	RasterIRQ(RasterTopLevel(),20,@USE_KERNAL);
	closeIrq();
//	setcharsetandscreenlocation(@tilesetLoc1,$4400);
end;



procedure InitAnimations();
var
	pa: pointer of animObject;

begin
	// walk left
	// l            r            u            d
	// 00 01 02 03  04 05 06 07  08 09 0a 0b  0c 0d 0e 0f 

	// walk right
	// l            r            u            d
	// 10 11 12 13  14 15 16 17  18 19 1a 1b  1c 1d 1e 1f 

	// stand
	// l  r  u  d
	// 20 21 22 23
	
	// swim l
	// l     r     u     d
	// 24 25 26 27 24 25 26 27

	// swim r
	// l     r     u     d
	// 28 29 2a 2b 28 29 2a 2b

	// TODO	
	// climb
	// l     r     u     d
	// 2c 2d 2e 2f 30 31 32 33

	// TODO	
	// robe
	// l     r     u     d
	// 34 35 36 37 48 49 4a 4b

 
	
	pa := #animList[@ANIM_WALK_L];
	pa.animSeq[0] := $00;
	pa.animSeq[1] := $04;
	pa.animSeq[2] := $08;
	pa.animSeq[3] := $0c;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_WALK_R];
	pa.animSeq[0] := $10;
 	pa.animSeq[1] := $14;
	pa.animSeq[2] := $18;
	pa.animSeq[3] := $1c;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;


	pa := #animList[@ANIM_STAND];
	pa.animSeq[0] := $20; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_SWIM_L];
	pa.animSeq[0] := $24; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_SWIM_R];
	pa.animSeq[0] := $28; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_CLIMB];
	pa.animSeq[0] := $2c; 
 	pa.animSeq[1] := $30;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_ROBE];
	pa.animSeq[0] := $34; 
 	pa.animSeq[1] := $38;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_PORTAL];
	pa.animSeq[0] := $A6; 
 	pa.animSeq[1] := $A8;
	pa.animSeq[2] := $AA;
	pa.animSeq[3] := $AC;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_LR_REPEAT;

	pa := #animList[@ANIM_SWITCH_ON];
	pa.animSeq[0] := $6E; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	
	
	pa := #animList[@ANIM_SWITCH_OFF];
	pa.animSeq[0] := $70; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	

	pa := #animList[@ANIM_DOOR_ON];
	pa.animSeq[0] := $76; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	
	
	pa := #animList[@ANIM_DOOR_OFF];
	pa.animSeq[0] := $74; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	

	pa := #animList[@ANIM_EXIT_ON];
	pa.animSeq[0] := $1e; 
 	pa.animSeq[1] := $20;
	pa.animSeq[2] := $22;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 3;
	pa.speed := 4;
	pa.mode := @ANIM_MODE_LR;	
	
	pa := #animList[@ANIM_EXIT_OFF];
	pa.animSeq[0] := $22; 
 	pa.animSeq[1] := $20;
	pa.animSeq[2] := $1e;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 3;
	pa.speed := 4;
	pa.mode := @ANIM_MODE_LR;	

end;

procedure InitSprites();
var
	i:byte;
begin
	// Set all sprites to be multicolor
	sprite_multicolor:=$ff;
	// Set common sprite multicolor #1 
	sprite_multicolor_reg1:=dark_grey;
	// Set  common sprite multicolor #2 
	sprite_multicolor_reg2:=white;
	for i := 0 to 8 do begin 
		sprite_color[i]:=light_red;
		SpritePos(0,0,i);
	end;
	// Turn on sprite 0 (or @useSprite)
	sprite_bitmask := $FF;
//	togglebit(sprite_bitmask,0,1);
end;
@endblock

function Pos2ObjectId(pos: byte) : byte;
var
	c: byte;
begin
	c := $FF;
	if(pos <> $FF) then begin
		if(mapback2[pos] <> $FF) then c := mapback2[pos]
		else if(mapback1[pos] <> $FF ) then c := mapback1[pos]
		else if(mapmain[pos] <> $FF) then c := mapmain[pos]
		else if(mapfront[pos] <> $FF) then c := mapfront[pos];
	end;
	Pos2ObjectId := c;
end; 

procedure InitActors();
var
	i,j,x,y,c : byte;
begin
	j := 0;
	for i := 0 to @MAX_ACTORS * @ACTOR_LENGTH step @ACTOR_LENGTH do
	begin
		actorList[j].event := lev0actor[i];
		actorList[j].action := lev0actor[i+1];
		actorList[j].senderId := Pos2ObjectId(lev0actor[i+2]);   
		actorList[j].receiverId := Pos2ObjectId(lev0actor[i+3]);
		actorList[j].param0 := lev0actor[i+4];
		actorList[j].param1 := lev0actor[i+5];
		actorList[j].param2 := lev0actor[i+6];
		actorList[j].param3 := lev0actor[i+7];
		inc(j);
	end;
end;

procedure InitMap();
var 
	i,x,y,c : byte;
begin
	ClearMap();
	countDyn := 0;
	countAnim := 0;

	for i:= 0 to @MAX_OBJECTS do begin
		deletedObjects[@MAX_OBJECTS - 1 - i] := i;
	end;	
	
	for i := 0 to @DIMTILES do
	begin
		c := lev0[i];
		x := mod(i,@DIMX);
		y := i / @DIMX;
		case c of
			@LEV_CHARACTER: InitCharacter(x,y,0);
			@LEV_BRICK: InitBrick(x, y);
			@LEV_STONE: InitStone(x, y);
			@LEV_WATER: InitWater(x, y);
			@LEV_WATER_UP: InitWaterFlow(x, y, 23, @UP);
			@LEV_WATER_DOWN: InitWaterFlow(x, y, 22, @DOWN);
			@LEV_WATER_LEFT: InitWaterFlow(x, y, 62, @LEFT);
			@LEV_WATER_RIGHT: InitWaterFlow(x, y, 63, @RIGHT);
			@LEV_SAND: InitSand(x, y);
			@LEV_SHIFT_UP: InitShiftPlattform(x, y,4,@UP);
			@LEV_SHIFT_DOWN: InitShiftPlattform(x, y,6,@DOWN);
			@LEV_SHIFT_RIGHT: InitShiftPlattform(x, y, 8,@RIGHT);
			@LEV_SHIFT_LEFT: InitShiftPlattform(x, y, 10,@LEFT);
			@LEV_LADDER: InitLadder(x,y);
			@LEV_ROBE_UP: InitRobe(x,y,100,@DOWN);
			@LEV_ROBE_DOWN: InitRobe(x,y,102,@UP);
			@LEV_ROBE_LEFT: InitRobe(x,y,104,@LEFT);
			@LEV_ROBE_RIGHT: InitRobe(x,y,106,@RIGHT);
			@LEV_PORTAL: InitPortal(x,y,@UP);
			@LEV_GRAVPAD_UP: InitGravPad(x,y,38,@UP);
			@LEV_GRAVPAD_DOWN: InitGravPad(x,y,80,@DOWN);
			@LEV_GRAVPAD_LEFT: InitGravPad(x,y,82,@LEFT);
			@LEV_GRAVPAD_RIGHT: InitGravPad(x,y,84,@RIGHT);
			@LEV_MIRROR_LEFT: InitMirror(x,y, 96, @TURN_LEFT);
			@LEV_MIRROR_RIGHT: InitMirror(x,y, 98, @TURN_RIGHT);
			@LEV_GLASS: InitMirror(x,y,36, @TURN_THROUGH);
			@LEV_LASER_TRANSPORT: InitLaserTransport(x,y);
			@LEV_LASER_TRANSPORT_ONCE: InitLaserTransportOnce(x,y);
			@LEV_PUSH_BOX: InitBox(x,y, 162 , 1);
			@LEV_PULL_BOX: InitBox(x,y, 164 , -1);
			@LEV_FONTAINE_DOWN: InitFontaine(x,y, 176, @DOWN);
			@LEV_FONTAINE_UP: InitFontaine(x,y,178,@UP);
			@LEV_FONTAINE_LEFT: InitFontaine(x,y, 180, @LEFT);
			@LEV_FONTAINE_RIGHT: InitFontaine(x,y,182,@RIGHT);
			@LEV_CANNON_DOWN: InitCannon(x,y, 14, @DOWN);
			@LEV_CANNON_UP: InitCannon(x,y,12,@UP);
			@LEV_CANNON_LEFT: InitCannon(x,y, 16, @LEFT);
			@LEV_CANNON_RIGHT: InitCannon(x,y,18,@RIGHT);
			@LEV_SWITCH_MANUAL: InitSwitchManual(x,y);
			@LEV_DOOR: InitDoor(x,y);
			@LEV_EXIT: InitExit(x,y);
		end;
	end;
end;

procedure DecreaseTextTimer();
begin
	if(textTimer > 0) then begin
		dec(textTimer);
		if(textTimer = 0) then ClearText();
	end; 
end;

begin
	preventirq();
	disableciainterrupts();
	setmemoryconfig(1,0,0);
		
	SCREEN_BG_COL:=BLACK;
	SCREEN_FG_COL:=BLACK;
	multicolor_char_col[1]:=brown;
	multicolor_char_col[2]:=grey;
	clearscreen($FF,^$0400);
	clearscreen($FF,^$4400);
	clearscreen(BLACK,^$D800);
	
	Init();
	InitMap();
	InitActors();	
	SwitchBank();
	PaintFull();
	SwitchBank();
	PaintFull();
	InitSprites();
	InitAnimations();
	//setmemoryconfig(1,@USE_KERNAL,0); // Enable all ram, turn off BASIC
	StartRasterChain(RasterTopLevel(), 0,@USE_KERNAL); // Don't use kernal
	frameStatus := 1;
	enableirq();
	enablerasterirq();
	DispatchEvent(@EVENT_INIT_LEVEL, $FF, $FF, $FF);
	While(true) do begin
		if(frameStatus = 0)	then begin
			inc(globaltime);	
			Update();
			Animate();
			CycleWater();
			DecreaseTextTimer();
	//		PaintFull();
			frameStatus := 1;
		end;
	end;
	Loop(); 
end.



